# This file defines our GraphQL schema.
# A comment just above a type, field, or parameter name will be treated as
# documentation for that object by GraphiQL or graphdoc documentation
# generators. You can use markdown syntax within comments for formatting.

#######################
# Custom directives
# These are specific to our implementation.
#######################

# Used to authorize access to a given query, mutation, or field
# based on permissions set in the user token.
# for example, to restrict a field foo to superadmins, add
#   foo: Foo # @scopes(scopes: ["superadmin"])
# Permission strings must EXACTLY match the permission objects defined
# in functional-permissions-lib. If the user does not have all required
# permissions, the field will contain null and the errors list will
# have an "access denied" error message.
directive # @scopes(
  # List of one or more scopes required for the field
  scopes: [String!]!
  # Whether or not to require _all_ scopes listed or only any one of them.
  # Default is All.
  require: ScopeRequirement = All
) on QUERY | MUTATION | FIELD

# Used to require authentication and to enforce organization-level
# authorization. This directive, with default parameters, is applied by
# default to all queries and mutations. Parameter values can be overridden
# by setting it explicitly on a field.
# The # @noAuth directive can be explicitly used on fields that do not
# require authentication.
# Examples:
#  Allow org-less tokens to access objects of type TemporalDataObject
#  based on the id parameter.
#   # @auth(allowOrgless: true, objectAuthType: TemporalDataObject)
# Allow org-less tokens to use the field with no object restrictions.
# The # @scopes directive might still apply.
#   # @auth(allowOrgless: true, skipObjectAuthorization: true)
# Allow org-less tokens to use the field if the ID referenced in parentId
# is in the allowed set of TemporalDataObjects. Useful for something like
# createAsset.
#   # @auth(allowOrgless: true, objectAuthType: TemporalDataObject,
#         objectAuthIdParam: parentId)
directive # @auth(
  # Whether or not to allow access for org-less (engine) tokens
  allowOrgless: Boolean = true
  # Whether or not to skip object-level authorization for org-less tokens.
  # Use with caution.
  skipObjectAuthorization: Boolean = false
  # The type of object that object-level access controls should apply to.
  # Must be set if allowOrgless is true and skipObjectAuthorization is false.
  objectAuthType: AuthObjectType
  # The name of the field parameter containing id(s) to query for.
  # Object-level authorization will authorize this value against the list of
  # allowed object resources for the token.
  objectAuthIdParam: String = "id"
) on QUERY | MUTATION | FIELD

# Used to explicitly declare that a given field does not require authentication.
# Use with caution.
directive # @noAuth on QUERY | MUTATION | FIELD

directive # @tokenType(type: TokenType!) on QUERY | MUTATION | FIELD

directive @log on QUERY | MUTATION | FIELD

directive @noLog on QUERY | MUTATION | FIELD

directive @featureFlag(
  # default value for the feature flag to use if it is not provided
  # in configuration or on the org
  defaultValue: Boolean = false
  # Optional name for the feature flag. The default will be the
  # mutation, query, or field name to which the directive is attached.
  name: String
) on QUERY | MUTATION | FIELD

directive # @audit(
  objectType: String
  action: AuditAction
  skip: Boolean = False
) on MUTATION

enum AuditAction {
  Create
  Update
  Delete
}

enum TokenType {
  API
  User
}

enum ScopeRequirement {
  Any
  All
}

enum AuthObjectType {
  TemporalDataObject
  Job
  Task
  Folder
}

# This is the root of our schema. If you're new to our API,
# browse into Query.
schema {
  # Queries are used to retrieve data.
  query: Query
  # Mutations are used to modify data -- to create, update, or delete.
  mutation: Mutation
}

# Queries are used to retrieve data. If you're new to our API,
# try the `me` query to explore the information you have access to.
# Hit `ctrl-space` at any time to activate field completion hints, and
# mouse over a field or parameter to see its documentation.
type Query {
  # Retrieve a list of temporal data objects.
  temporalDataObjects(
    # Application ID to get TDOs for. Defaults to the user's own application.
    applicationId: ID
    # Provide an ID to retrieve a single specific TDO.
    id: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Optionally, specify a source ID. TDOs ingested from this source will
    # be returned.
    sourceId: ID
    # Optionally, specify a scheduled job ID. TDOs ingested under this
    # scheduled job will be returned.
    scheduledJobId: ID
    # Whether to retrieve only tdos with the specified sampleMedia value
    sampleMedia: Boolean = false
    # Whether to retrieve public data that is not part of the user's organization.
    # The default is false. Pass true to include public data in the result set.
    includePublic: Boolean = false
    orderBy: TemporalDataObjectOrderBy = createdDateTime
    orderDirection: OrderDirection = desc
    # Provide optional filters against any date/time field to filter
    # objects within a given time window.
    # Matching objects must meet all of the given conditions.
    dateTimeFilter: [TemporalDataObjectDateTimeFilter!]
    # Retrieve TDOs associated with the given mention
    mentionId: ID
  ): TDOList
    # @scopes(scopes: ["recording.read"])
    # @auth(allowOrgless: true, objectAuthType: TemporalDataObject)
  # Retrieve a single temporal data object
  temporalDataObject(
    # the TDO ID
    id: ID!
  ): TemporalDataObject
    # @scopes(scopes: ["recording.read"])
    # @auth(allowOrgless: true, objectAuthType: TemporalDataObject)
  # Retrieve a single Asset
  asset(
    # The asset ID
    id: ID!
  ): Asset # @scopes(scopes: ["recording.read"])
  # Retrieve a single Widget
  widget(
    # The widget ID
    id: ID!
    collectionId: ID!
    organizationId: ID!
  ): Widget # @scopes(scopes: ["collections.access"])
  # Retrieve clone job entries
  cloneRequests(
    # Provide an ID to retrieve a single specific clone request.
    id: ID
    # Application ID to get clone requests for. Defaults to the user's own application.
    applicationId: ID
    offset: Int = 0
    limit: Int = 30
  ): CloneRequestList # @scopes(scopes: ["recording.create"])
  # Retrieve engines
  engines(
    # Provide an ID to retrieve a single specific engine.
    id: ID
    ids: [ID!]
    # Provide a category ID to filter by engine category.
    categoryId: String
    # provide a category name or ID to filter by engine category
    category: String
    # Provide a list of states to filter by engine state.
    state: [EngineState]
    # If true, return only engines owned by the user's organization.
    owned: Boolean = false
    # If true, return only engines that require a library.
    libraryRequired: Boolean
    # If true, return only engines that create their own TDO.
    # If false, return only engines that do not create a TDO.
    # If not set, return either.
    createsTDO: Boolean
    # Provide a name, or part of a name, to search by engine name
    name: String
    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30
    # Filters for engine attributes
    filter: EngineFilter
    # Provide a list of EngineSortField to sort by.
    orderBy: [EngineSortField]
  ): EngineList
    # @scopes(
      scopes: [
        "developer.engine.read"
        "cms.workflows.create"
        "cms.job.create"
        "job.create"
        "cms.access"
        "discovery.access"
      ]
      require: Any
    )
    # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Retrieve a single engine by ID
  engine(
    # Provide the engine ID
    id: ID!
  ): Engine
    # @scopes(
      scopes: [
        "developer.engine.read"
        "cms.workflows.create"
        "cms.job.create"
        "job.create"
        "cms.access"
        "discovery.access"
      ]
      require: Any
    )
  engineBuild(
    # Provide the build ID
    id: ID!
  ): Build # @scopes(scopes: ["developer.build.read"])
  # Retrieve engine categories
  engineCategories(
    # Provide an ID to retrieve a single specific engine category.
    id: ID
    # Provide a name, or part of one, to search by category name
    name: String
    # Return all categories of an engine type
    type: String
    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30
  ): EngineCategoryList
    # @scopes(
      scopes: [
        "developer.engine.read"
        "cms.workflows.create"
        "cms.job.create"
        "job.create"
        "cms.access"
        "discovery.access"
      ]
      require: Any
    )
  # Retrieve a specific engine category
  engineCategory(
    # Supply the ID of the engine category to retrieve
    id: ID!
  ): EngineCategory
    # @scopes(
      scopes: [
        "developer.engine.read"
        "cms.workflows.create"
        "cms.job.create"
        "job.create"
        "cms.access"
        "discovery.access"
      ]
      require: Any
    )
  # Retrieve jobs
  jobs(
    # Provide an ID to retrieve a single specific job.
    id: ID
    # Provide a list of status strings to filter by status
    status: [JobStatusFilter!]
    applicationStatus: String
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify the maximum number of results to included in this response, or page size.
    limit: Int = 30
    # Provide an application ID to filter jobs for a given application.
    # Defaults to the user's own application.
    applicationId: ID
    # Provide a target ID to get the set of jobs running against a particular TDO.
    targetId: ID
    # Provide a cluster ID to get the jobs running on a specific cluster
    clusterId: ID
    # Provide a list of scheduled job IDs to get jobs associated with the scheduled jobs
    scheduledJobIds: [ID!]
    # Return only jobs that are (true) or are not (false) associated with a scheduled job
    hasScheduledJobId: Boolean
    # Provide sort information. The default is to sort by
    # createdDateTime descending.
    orderBy: [JobSortField!]
    # Filter by date/time field
    dateTimeFilter: [JobDateTimeFilter!]
    # Provide list of application IDs to filter jobs.
    # Defaults to the user's own application.
    applicationIds: [ID]
  ): JobList # @scopes(scopes: ["job.read"])
  # Retrieve a single job by ID
  job(
    # Provide the job ID.
    id: ID!
  ): Job # @scopes(scopes: ["job.read"])
  # Retrieve a single task by ID
  task(
    # Provide the task ID.
    id: ID!
  ): Task # @scopes(scopes: ["task.read"])
  # Retrieve entity identifier types
  entityIdentifierTypes(
    # Provide an ID to retrieve a single specific entity identifier type.
    id: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): EntityIdentifierTypeList
  entityIdentifierType(
    # Provide the entity identifier type ID
    id: ID!
  ): EntityIdentifierType
  # Retrieve all library types
  libraryTypes(
    # Provide an ID to retrieve a single specific library type.
    id: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): LibraryTypeList
  # Retrieve a single library type
  libraryType(
    # Provide an ID to retrieve a single specific library type.
    id: ID
  ): LibraryType
  # Retrieve libraries and entities
  libraries(
    # Provide an ID to retrieve a single specific library.
    id: ID
    # Provide a name string to search by name.
    name: String
    # Provide the name or ID of a library to search for libraries
    # that contain that type.
    type: String
    # Provide the id of an entity identifier type to search for libraries that correlate
    # to that type.
    entityIdentifierTypeIds: [String!]
    # Specify true if only libraries owned by the user's organization
    # should be returned. Otherwise, shared libraries will be included.
    includeOwnedOnly: Boolean = false
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Specify a field to order by
    orderBy: LibraryOrderBy
    # Specify the direction to order by
    orderDirection: OrderDirection
  ): LibraryList
  # Retrieve a specific library
  library(
    # Provide a library ID.
    id: ID!
  ): Library # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve a specific library engine model
  libraryEngineModel(
    # Provide the library engine model ID
    id: ID!
  ): LibraryEngineModel # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve a specific entity
  entity(
    # Provide an entity ID.
    id: ID!
  ): Entity # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve a list of entities across libraries
  entities(
    # Provide a list of entity IDs to retrieve those entities
    ids: [ID!]
    # Provide a list of library IDs to retrieve entities across
    # multiple libraries.
    libraryIds: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve applications. These are custom applications integrated into
  # the Veritone platform using the VDA framework.
  applications(
    # Provide an ID to retrieve a single specific application.
    id: ID
    # Provide a status, such as "draft" or "active"
    status: ApplicationStatus
    # If true, return only applications owned by the user's organization.
    owned: Boolean
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): ApplicationList
    # @scopes(
      scopes: ["developer.access", "cms.access", "discovery.access"]
      require: Any
    )
  # Retrieve organizations
  organizations(
    # Provide an ID to retrieve a single specific organization.
    id: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Provide a property from the organization kvp to filter the organizaion list.
    kvpProperty: String
    # Provide value to for the kvpFeature filter.
    # If not present the filter becomes kvpProperty existence filter
    kvpValue: String
  ): OrganizationList # @scopes(scopes: ["admin.org.read"])
  # Retrieve a single organization
  organization(
    # The organization ID
    # TODO take application ID as well as org ID
    id: ID!
  ): Organization # @scopes(scopes: ["admin.org.read"])
  # Retrieve permissions
  permissions(
    # Provide an ID to retrieve a single specific permission.
    id: ID
    name: String
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): PermissionList # @scopes(scopes: ["admin.user.read"])
  # Retrieve users
  users(
    # Provide an ID to retrieve a single specific user.
    # A user ID is a string in UUID format.
    id: ID
    # Provide IDs to retrieve multiple users by ID.
    ids: [ID]
    # Provide a name, or part of one, to search by name.
    name: String
    # Provide a list of organization IDs to filter your search by organization.
    organizationIds: [ID]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Include all organization users.
    includeAllOrgUsers: Boolean = False
  ): UserList # @scopes(scopes: ["admin.user.read"])
  # Retrieve an individual user
  user(
    # The user ID.
    # A user ID is a string in UUID format.
    id: ID!
    organizationIds: [ID]
  ): User # @scopes(scopes: ["admin.user.read"])
  # Retrieve user's organization API tokens
  tokens: [Token] # @scopes(scopes: ["admin.org.read"]) # @tokenType(type: User)
  # Retrieve information for the current logged-in user
  me: User # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve groups
  groups(
    # Provide an ID to retrieve a specific group by ID
    id: ID
    # Provide IDs to retrieve multiple groups by ID
    ids: [ID]
    # Provide a name, or part of one, to search for groups by name
    name: String
    # Provide a list of organization IDs to retrieve groups defined
    # within certain organizations.
    organizationIds: [ID]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): GroupList # @scopes(scopes: ["admin.group.read"])
  # Retrieve a single mention
  mention(
    # The mention ID
    mentionId: ID!
    # Comments pagination - limit
    limit: Int = 25
    # Comments pagination - limit
    offset: Int = 0
    # The user who owns the mention.
    userId: String
  ): Mention # @scopes(scopes: ["discovery.mentions.read"])
  # Search for mentions across an index.
  # This query requires a user token.
  searchMentions(
    # JSON structure containing the search query.
    # TODO link to syntax documentation
    search: JSONData!
  ): SearchResult
    # @scopes(
      scopes: [
        "discovery.access"
        "discovery.mentions.read"
        "collections.collections.read"
      ]
      require: Any
    )
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Search for media across an index.
  # This query requires a user token.
  searchMedia(
    # JSON structure containing the search query.
    # TODO link to syntax documentation
    search: JSONData!
  ): SearchResult # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve the root folders for an organization
  rootFolders(
    # The type of root folder to retrieve
    type: RootFolderType
  ): [Folder]
    # @tokenType(type: User)
    # @scopes(
      scopes: ["collections.collections.read", "cms.media.read"]
      require: Any
    )
  # Retrieve a single folder. Used to navigate the folder tree structure.
  folder(
    # Provide an ID to retrieve a single specific user.
    id: ID!
  ): Folder
    # @scopes(
      scopes: ["collections.collections.read", "cms.media.read"]
      require: Any
    )
  # Retrieve a single job
  job(
    # the job ID
    id: ID!
  ): Job # @scopes(scopes: ["job.read"])
  # Retrieve a single application
  application(
    # The application ID
    id: ID!
  ): Application # @scopes(scopes: ["developer.access"])
  # Retrieve a single ingestion configuration
  ingestionConfiguration(
    # The configuration ID
    id: ID!
  ): IngestionConfiguration # # @scopes(scopes: ["ingestion.read"])
  # Retrieve ingestion configurations
  ingestionConfigurations(
    # Supply an ingestion configuration ID to retrieve a single Ingestion
    id: ID
    # Offset
    offset: Int = 0
    # Limit
    limit: Int = 30
    name: String
    startDate: DateTime
    endDate: DateTime
    # Specify one or more sources to filter by source type
    sources: [String!]
    # Supply an application ID to retrieve configurations only for
    # that application.
    applicationId: ID
    # Email address configured for ingestion
    emailAddress: String
  ): IngestionConfigurationList
  # Retrieve a list of schemas for structured data ingestions
  schemas(
    # Id of a schema to retrieve
    id: ID
    # Ids of schemas to retrieve
    ids: [ID!]
    # Specify the id of the DataRegistry to get schemas
    dataRegistryId: ID
    # Specify one or more statuses to filter by schema status
    status: [SchemaStatus!]
    # Specify a major version to filter schemas
    majorVersion: Int
    # Specify a data registry name to filter schemas
    name: String
    # The strategy used to find data registry name
    nameMatch: StringMatch = startsWith
    # Limit
    limit: Int = 30
    # Offset
    offset: Int = 0
    # Specify one or more fields and direction to order results
    orderBy: [SchemaOrder]
  ): SchemaList # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve a schema for structured data ingestions
  schema(
    # Supply the ID of the schema to retrieve
    id: ID!
  ): Schema # @auth(allowOrgless: true, skipObjectAuthorization: true)
  schemaProperties(
    dataRegistryVersion: [DataRegistryVersion!]
    search: String
    # Limit
    limit: Int = 30
    # Offset
    offset: Int = 0
  ): SchemaPropertyList
  # Retrieve a structured data object
  structuredData(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID!
    # Schema Id for the structured data object to retrieve
    schemaId: ID!
  ): StructuredData # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Retrieve a structured data object
  structuredDataObject(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID!
    # Schema Id for the structured data object to retrieve
    schemaId: ID!
  ): StructuredData # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Retrieve a paginated list of structured data object
  structuredDataObjects(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID
    # List of Ids of the structured data objects to retrieve. This will override filters.
    ids: [ID!]
    # Schema Id for the structured data object to retrieve
    schemaId: ID!
    limit: Int = 30
    offset: Int = 0
    # Query to filter SDO. Supports operations such as and, or, eq, gt, lt, etc.
    # TODO link to syntax documentation
    filter: JSONData
  ): StructuredDataList # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Returns information about the GraphQL server, useful
  # for diagnostics. This data is primarily used by Veritone
  # development, and some fields may be restricted to Veritone administrators.
  graphqlServiceInfo: GraphQLServiceInfo # @noAuth
  # Returns a signed writable S3 URL. A client can then
  # upload to this URL with an HTTP PUT without providing
  # any additional authorization (_note_: it must be a PUT.
  # A POST will fail.)
  getSignedWritableUrl(
    # Optional key of the object to generate a writable
    # URL for. If not provided, a new, unique key will
    # be generated. If a key is provided and resembles a file name
    # (with extension delimited by .), a UUID will be inserted
    # into the file name, leaving the extension intact.
    # If a key is provided and does not resemble
    # a file name, a UUID will be appended.
    key: String
  ): WritableUrlInfo
    # @scopes(
      scopes: [
        "recording.create"
        "developer.engine.create"
        "admin.org.update"
        "admin.user.create"
        "admin.user.update"
        "admin.org.update"
        "admin.profile.update"
        "job.create"
        "recording.update"
        "developer.engine.update"
      ]
      require: Any
    )
    # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Return writable storage URLs in bulk.
  # A maximum of 1000 can be created in one call.
  # See `getSignedWritableUrl` for details on usage of the
  # response contents.
  getSignedWritableUrls(
    # Number of signed URLs to return
    number: Int!
  ): [WritableUrlInfo!]!
    # @scopes(
      scopes: [
        "recording.create"
        "developer.engine.create"
        "admin.org.update"
        "admin.user.create"
        "admin.user.update"
        "admin.org.update"
        "admin.profile.update"
        "job.create"
        "recording.update"
        "developer.engine.update"
      ]
      require: Any
    )
    # @auth(allowOrgless: true, skipObjectAuthorization: true)

  myRights: RightsListing
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Retrieve the shared folders for an organization
  sharedFolders: [Folder]
    # @tokenType(type: User)
    # @scopes(scopes: ["collections.collections.read"])

  watchlists(
    id: ID
    maxStopDateTime: DateTime
    minStopDateTime: DateTime
    minStartDateTime: DateTime
    maxStartDateTime: DateTime
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: WatchlistOrderBy = createdDateTime
    orderDirection: OrderDirection = desc
  ): WatchlistList

  watchlist(id: ID!): Watchlist

  mentionStatusOptions: [MentionStatus!]!

  dataRegistries(
    id: ID
    name: String
    nameMatch: StringMatch = startsWith
    offset: Int = 0
    limit: Int = 30
    orderBy: DataRegistryOrderBy = createdDateTime
    orderDirection: OrderDirection = desc
    filterByOwnership: SchemaOwnership = all
  ): DataRegistryList
  dataRegistry(id: ID!): DataRegistry
  schema(id: ID!): Schema

  subscription(id: ID!): Subscription!

  cognitiveSearch(id: ID!): CognitiveSearch!

  collections(
    id: ID
    mentionId: ID
    offset: Int = 0
    limit: Int = 30
  ): CollectionList!

  collection(id: ID!): Collection!

  mentions(
    id: ID
    # Get mentions created from the specified watchlist
    watchlistId: ID
    # Get mentions associated with the specified source
    sourceId: ID
    # Get mentions associated with sources of the specified source type
    sourceTypeId: ID
    # Get mentions associated directly with the specific TDO
    tdoId: ID

    # Specify date/time filters against mention fields.
    # Querying for mentions can be expensive. If the query does not
    # include a filter by `id`, `tdoId`, `sourceId`, `watchlistId`, or
    # a user-provided `dateTimeFilter`, a default filter of the
    # past 7 days is applied.
    dateTimeFilter: [MentionDateTimeFilter!]

    # Set order information on the query. Multiple fields
    # are supported.
    orderBy: [MentionOrderBy!]

    offset: Int = 0
    limit: Int = 30
  ): MentionList
  # Retrieves engine results by TDO and engine ID or by job ID.
  engineResults(
    # Provide the ID of the TDO containing engine results to retrieve.
    # If this parameter is used, engineIds or engineCategoryIds must also be set.
    # Results for _only_ the specified TDO will be returned.
    tdoId: ID
    # Provide the ID of the Source containing engine results to retrieve.
    # If this parameter is used, engineIds or engineCategoryIds must also be set.
    # This takes priority over tdoId.
    sourceId: ID
    # Provide one or more engine IDs to retrieve engine results by
    # ID. This parameter is mandatory if tdoId is used, but optional
    # if jobId or engineCategory is used.
    engineIds: [ID!]
    # Provide one or more category IDs to get all results from that categroy.
    engineCategoryIds: [ID!]
    # Provide a job ID to retrieve engine results for the job.
    jobId: ID
    # Provide a mention ID to retrieve engine results for the mention.
    mentionId: ID
    # Start offset ms for the results.
    startOffsetMs: Int
    # End offset ms for the results.
    stopOffsetMs: Int
    # Start date for the results. Takes priority over startOffsetMs.
    startDate: DateTime
    # End date for the results. Takes priority over stopOffsetMs.
    stopDate: DateTime
    # Whether or not to exclude user edited engine results. Defaults to false.
    ignoreUserEdited: Boolean = false
    # A TDO ID can be provided for use if the provided `sourceId` and/or
    # `mentionId` parameters do not resolve to a logical set of TDOs.
    # Depending on parameter settings and available data,
    # results from other TDOs can be included in the response.
    fallbackTdoId: ID
  ): EngineResultList
    # @scopes(
      scopes: [
        "recording.read"
        "task.read"
        "discovery.mentions.read"
        "collections.collections.read"
      ]
      require: Any
    )

  trigger(id: ID!): Trigger
  triggers: [Trigger]
  # Fetch all saved searches that the current user has made
  # Fetch all saved searches that have been shared with
  # the current users organization
  # Include any saved searches that the user has created
  savedSearches(
    offset: Int = 0
    limit: Int = 30
    includeShared: Boolean = false
    filterByName: String
    orderBy: SavedSearchOrderBy
    orderDirection: OrderDirection
  ): SavedSearchList!

  # Retrieve a list of export requests
  exportRequests(
    # Provide an ID to retrieve a single export request
    id: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Provide a list of status options to filter by status
    status: [ExportRequestStatus!]
  ): ExportRequestList!

  exportRequest(id: ID!): ExportRequest!

  # Retrieve a event by id
  event(id: ID!): Event!

  # Retrieve a list of events by application
  events(application: String!): [Event!]

  # This query returns information about time zones recognized by this
  # server. The information is static and does not change.
  timeZones: [TimeZone!]!

  # Examine entries from the audit log. All operations that modify data are
  # written to the audit log. Only entries for the user's own organization
  # can be queried.
  # All queries are bracketed by a time window. A default time window is applied
  # if the `toDateTime` and/or `fromDateTime` parameters are not provided.
  # The maximum time window length is 30 days.
  # Only Veritone and organization administrators can use this query.
  auditLog(
    # Date/time up to which entries will be returned. In other words, the
    # end of the query time window.
    # Defaults to the current time.
    toDateTime: DateTime
    # Date/time from which entries will be returned. In other words, the
    # start of the query time window.
    # Defaults to the `toDateTime` minus 7 days.
    fromDateTime: DateTime
    # Organization ID to query records for. This value can only be used by
    # Veritone administrators. Any value provided by user administrators will
    # be ignored.
    organizationId: ID
    # User name on audit entry. Must be exact match.
    userName: String
    # IP address of the client that generated the audit action. Must be exact match.
    clientIpAddress: String
    # HTTP user agent of the client that generated the audit action. Must be exact match.
    clientUserAgent: String
    # The event type, such as `Create`, `Update`, or `Delete`.
    # Must be exact match.
    eventType: String
    # The ID of the object involved in the audit action. The format of this ID
    # varies by object type. Must be exact match.
    objectId: ID
    # The type of the object involved in the audit action, such as `Watchlist`
    # or `TemporalDataObject`. Must be exact match.
    objectType: String
    # Whether or not the action was successful.
    success: Boolean
    # The unique ID of an audit log entry. Multiple values can be provided.
    id: [ID!]
    # Offset into result set, for paging.
    offset: Int = 0
    # Limit on result size, for paging (page size). Audit queries are
    # lightweight so the default of 100 is higher than the default offset
    # used elsewhere in the API.
    limit: Int = 100
    # Order information. Default is order by `createdDateTime` descending.
    orderBy: [AuditLogOrderBy!]
  ): AuditLogEntryList!
    # @scopes(
      scopes: [
        "superadmin"
        "veritone.superadmin"
        "veritone.financeadmin"
        "admin.access"
      ]
      require: Any
    )

  # Get the specific Mention shared
  sharedMention(id: ID!, offset: Int = 0, limit: Int = 0): MentionList
    # @noAuth
    @featureFlag(name: "sharedMention")

  # Retrieve Veritone Workflow instance status by id
  workflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!

  # Get a specific workflowRuntimeData based on dataKey
  workflowRuntimeStorageData(
    # Unique id of the workflow instance
    workflowRuntimeId: ID!
    # The unique id to rertrieve a single workflow data
    storageKey: String
    # A prefix filter used to return a set of workflow data
    # items whose dataKey starts with dataKeyPrefix
    storageKeyPrefix: String
    # Offset for paging
    offset: Int = 0
    # Limit on result size, for paging (page size).
    # workflowRuntimeData can be arbitrary large therefore smaller paging shoulf be preffered
    limit: Int = 30
  ): WorkflowRuntimeStorageDataList!
    # @scopes(
      scopes: ["superadmin", "veritone.superadmin", "workflow.create"]
      require: Any
    )

  # Get list process templates by id or current organizationId
  processTemplates(
    id: ID
    offset: Int = 0
    limit: Int = 30
  ): ProcessTemplateList! # @scopes(scopes: ["cms.workflows.read"])
}

type ProcessTemplateList implements Page {
  records: [ProcessTemplate!]
  offset: Int!
  limit: Int!
  count: Int
}

type ProcessTemplate {
  id: ID!
  organizationId: ID!
  name: String!
  taskList: JSONData!
}

# Specifies an "order by" entry in the `auditLog` query
input AuditLogOrderBy {
  field: AuditLogOrderByField
  direction: OrderDirection
}

# Fields that can be set in an `auditLog` `orderBy` parameter
enum AuditLogOrderByField {
  id
  objectId
  objectType
  createdDateTime
  eventType
  userName
  clientIpAddress
  clientUserAgent
  success
}

# Information about a time zone
type TimeZone {
  # Time zone name, such as `America/Los_Angeles`
  name: String!
  # Known abbreviations for the time zone. These may include
  # offset variations such as those caused by daylight savings time.
  abbreviations: [TimeZoneAbbreviation!]!
}

# Information about a time zone abbreviation or variant.
type TimeZoneAbbreviation {
  # The abbreviation, such as "PST" or "UTC"
  name: String!
  # The offset from UTC in string form, such as `-08:00` for `PST`.
  offset: String
  # The offset from UTC in minutes, such as `-480` for `PST`.
  offsetMinutes: Int
}

type ExportRequestList implements Page {
  records: [ExportRequest!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum SavedSearchOrderBy {
  name
  createdDateTime
  sharedWithOrganization
}

type SavedSearchList implements Page {
  records: [SavedSearch!]
  count: Int
  offset: Int!
  limit: Int!
}

input TaskDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: TaskDateTimeField!
}

enum TaskDateTimeField {
  createdDateTime
  modifiedDateTime
}

input JobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: JobDateTimeField!
}

enum SchemaOwnership {
  mine
  others
  all
}

enum JobDateTimeField {
  createdDateTime
  modifiedDateTime
}

enum TemporalDataObjectOrderBy {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

# Specify a filter on a TemporalDataObject date/time field.
# At least one of `toDateTime` and `fromDateTime` must be provided.
input TemporalDataObjectDateTimeFilter {
  # Match if the field value is `toDateTime` or earlier
  toDateTime: DateTime
  # Whether the toDateTime is inclusive or exclusive of the input timestamp
  toDateTimeExclusive: Boolean = false
  # Match if the field value is `fromDateTime` or later
  fromDateTime: DateTime
  # Whether the fromDateTime is inclusive or exclusive of the input timestamp
  fromDateTimeExclusive: Boolean = false
  # Identify the field to filter on.
  field: TemporalDataObjectDateTimeField!
}

enum TemporalDataObjectDateTimeField {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

enum WatchlistOrderBy {
  createdDateTime
  modifiedDateTime
  stopDateTime
  startDateTime
  name
}

type RightsListing {
  operations: [String!]!
  resources: JSONData
}

# Mutations are used to modify data. Each mutation takes an input
# that contains the data necessary to create or update the data
# in question.
type Mutation {
  # Create a new temporal data object
  createTDO(
    # Fields required to create a TDO
    input: CreateTDO
  ): TemporalDataObject
    # @scopes(scopes: ["recording.create"])
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Update a temporal data object
  updateTDO(
    # Fields required to update a TDO
    input: UpdateTDO
  ): TemporalDataObject # @scopes(scopes: ["recording.update"])
  # Delete a temporal data object. The TDO metadata, its assets and
  # all storage objects, and search index data are deleted.
  # Engine results stored in related task objects are not.
  # cleanupTDO can be used to selectively delete certain data on the TDO.
  deleteTDO(
    # Supply the ID of the TDO to delete
    id: ID!
  ): DeletePayload
    # @scopes(scopes: ["recording.delete"])
    # @audit(objectType: "TemporalDataObject")
  # Delete partial information from a temporal data object.
  # Use the delete options to control exactly which data is deleted.
  # The default is to delete objects from storage and the search index,
  # while leaving TDO-level metadata and task engine results intact.
  # To permanently delete the TDO, use delete TDO.
  cleanupTDO(
    # Supply the ID of the TDO to clean up.
    id: ID!
    # Supply a list of cleanup options. See TDOCleanupOption
    # for details. If not provided, the server will use default settings.
    options: [TDOCleanupOption!] = [storage, searchIndex]
  ): DeletePayload
    # @scopes(scopes: ["recording.update", "recording.delete"])
    # @audit(action: Update)
  # Create a task log by using
  # multipart form POST.
  createTaskLog(
    # Fields needed to create a task log.
    input: CreateTaskLog!
  ): TaskLog
    # @scopes(scopes: ["task.update"], require: Any)
    # @auth(
      allowOrgless: true
      objectAuthType: Task
      objectAuthIdParam: "input.taskId"
    )
  # Create a media asset. Optionally, upload content using
  # multipart form POST.
  createAsset(
    # Fields needed to create an asset.
    input: CreateAsset!
  ): Asset
    # @scopes(scopes: ["recording.update"])
    # @auth(
      allowOrgless: true
      objectAuthType: TemporalDataObject
      objectAuthIdParam: "input.containerId"
    )
  # Delete an asset
  deleteAsset(
    # Provide the ID of the asset to delete.
    id: ID!
  ): DeletePayload # @scopes(scopes: ["recording.update"])
  # Update an asset
  updateAsset(
    # Fields needed to update an asset.
    input: UpdateAsset!
  ): Asset # @scopes(scopes: ["recording.update"])
  # Start a clone job. A clone creates a new TDO
  # that links back to an existing TDO's assets
  # instead of creating new ones and is used
  # primarily to handle sample media.
  requestClone(
    # Fields needed to request a new clone job.
    input: RequestClone
  ): CloneRequest # @scopes(scopes: ["recording.read"])
  # Create a new engine. The engine will need to go
  # through a sequence of workflow steps before
  # use in production. See VDA documentation for details.
  createEngine(
    # Fields needed to create a new engine
    input: CreateEngine
  ): Engine # @scopes(scopes: ["developer.engine.create"])
  # Update an engine. Engines are subject to specific
  # workflow steps. An engine's state determines what
  # updates can be made to it. See VDA documentation for
  # details.
  updateEngine(
    # Fields needed to update an engine
    input: UpdateEngine
  ): Engine # @scopes(scopes: ["developer.engine.update"])
  # Delete an engine
  deleteEngine(
    # Provide the ID of the engine to delete
    id: ID!
  ): DeletePayload # @scopes(scopes: ["developer.engine.delete"])
  # Create an engine build.
  createEngineBuild(
    # Fields needed to create an engine build.
    input: CreateBuild!
  ): Build # @scopes(scopes: ["developer.build.create"])
  # Update an engine build. Engine builds are subject to
  # specific workflow steps. A build's state determines what
  # updates can be made to it. See VDA documentation for details.
  updateEngineBuild(
    # Fields needed to update an engine build.
    input: UpdateBuild!
  ): Build # @scopes(scopes: ["developer.build.update"])
  # Delete an engine build
  deleteEngineBuild(
    # Fields needed to delete an engine build.
    input: DeleteBuild!
  ): DeletePayload # @scopes(scopes: ["developer.build.delete"])
  # Update a task
  updateTask(
    # Fields required to update a task.
    input: UpdateTask
  ): Task
    # @scopes(scopes: ["task.update"])
    # @auth(
      allowOrgless: true
      objectAuthType: Task
      objectAuthIdParam: "input.id"
    )
  # Poll a task
  pollTask(
    # Fields required to poll a task.
    input: PollTask
  ): Task
    # @scopes(scopes: ["task.read", "task.update"], require: Any)
    # @auth(
      allowOrgless: true
      objectAuthType: Task
      objectAuthIdParam: "input.id"
    )
  # Create a job
  createJob(
    # Fields required to create a job.
    input: CreateJob
  ): Job
    # @scopes(scopes: ["job.create"])
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Cancel a job. This action effectively deletes the job,
  # although a records of job and task execution remains in
  # Veritone's database.
  cancelJob(
    # Supply the ID of the job to delete.
    id: ID!
  ): DeletePayload # @scopes(scopes: ["job.delete"]) # @audit(action: Delete)
  # Retry a job. This action applies only to jobs
  # that are in a failure state. The task sequence
  # for the job will be restarted in its original
  # configuration.
  retryJob(
    # Supply the ID of the job to retry.
    id: ID!
  ): Job # @scopes(scopes: ["job.update"])

  updateJobs(input: UpdateJobs!): JobList

  # Create a new application. An application must
  # go through a sequence of workflow steps before
  # it is available in production. See the VDA documentation
  # for details.
  createApplication(
    # Fields needed to create a new custom application.
    input: CreateApplication
  ): Application # @scopes(scopes: ["developer.engine.create"])
  # Delete an application
  deleteApplication(
    # Supply the ID of the application to delete.
    id: ID!
  ): DeletePayload # @scopes(scopes: ["developer.engine.delete"])
  # Update a custom application. Applications are subject to
  # specific workflows. The current application state determines
  # what updates can be made to it. See VDA documentation for details.
  updateApplication(
    # Fields required to update a custom application.
    input: UpdateApplication
  ): Application # @scopes(scopes: ["developer.engine.update"])
  # Bulk delete context meu extensions.
  bulkDeleteContextMenuExtensions(
    input: BulkDeleteContextMenuExtensions
  ): ContextMenuExtensionList # @scopes(scopes: ["developer.engine.delete"])
  # Update an organization
  updateOrganization(
    # Fields required to update an organization.
    input: UpdateOrganization!
  ): Organization # @scopes(scopes: ["admin.org.update"])
  addToEngineWhitelist(toAdd: SetEngineWhitelist!): EngineWhitelist
    # @scopes(scopes: ["superadmin"])
    # @audit(action: Update)
  addToEngineBlacklist(toAdd: SetEngineBlacklist!): EngineBlacklist
    # @scopes(scopes: ["superadmin"])
    # @audit(action: Update)
  deleteFromEngineBlacklist(toDelete: SetEngineBlacklist!): EngineBlacklist
    # @scopes(scopes: ["superadmin"])
  deleteFromEngineWhitelist(toDelete: SetEngineBlacklist!): EngineWhitelist
    # @scopes(scopes: ["superadmin"])
  # Create an entity identifier type, such as "face" or "image".
  # Entity identifier types are typically created or modified
  # only by Veritone engineering. Most libraries and
  # entities will use existing entity identifier types.
  createEntityIdentifierType(
    # Fields required to create an entity identifier type.
    input: CreateEntityIdentifierType!
  ): EntityIdentifierType
  # Update an entity identifier type.
  updateEntityIdentifierType(
    # Fields required to update an entity identifier type.
    input: UpdateEntityIdentifierType!
  ): EntityIdentifierType
  # Create a library type, such as "ad" or "people".
  # Entity identifier types are typically created or modified
  # only by Veritone engineering. Most libraries
  # will use existing entity identifier types.
  createLibraryType(
    # Fields needed to create a new library type.
    input: CreateLibraryType!
  ): LibraryType
  # Update a library type.
  updateLibraryType(
    # Fields needed to update a library type.
    input: UpdateLibraryType!
  ): LibraryType
  # Create a new library.
  # Once the library is created, the client can add
  # entities and entity identifiers. Note that the
  # library type determines what types of entity identifiers
  # can be used within the library.
  createLibrary(
    # Fields needed to create a new library.
    input: CreateLibrary!
  ): Library
  # Update an existing library.
  updateLibrary(
    # Fields needed to update a library
    input: UpdateLibrary!
  ): Library
  # Delete a library. This mutation will also delete all entities,
  # entity identifiers, library engine models, and associated objects.
  deleteLibrary(
    # Provide the ID of the library to delete.
    id: ID!
  ): DeletePayload
  # Publish a new version of a library.
  # Increments library version by one and trains compatible engines.
  publishLibrary(
    # ID of the library to publish
    id: ID!
  ): Library
  # Create a new entity.
  createEntity(
    # Fields required to create a new entity.
    input: CreateEntity!
  ): Entity
  # Update an entity.
  updateEntity(
    # Fields required to update an entity.
    input: UpdateEntity!
  ): Entity
  # Delete an entity. This mutation will also delete all associated
  # entity identifiers and associated objects.
  deleteEntity(
    # Supply the ID of the entity to delete.
    id: ID!
  ): DeletePayload
  # Create an entity identifier.
  # This mutation accepts file uploads. To use this mutation and upload a file,
  # send a multipart form POST containing two parameters:  `query`, with the
  # GraphQL query, and `file` containing the file itself.
  # For more information see the documentation at https://veritone-developer.atlassian.net/wiki/spaces/DOC/pages/13893791/GraphQL.
  createEntityIdentifier(
    # Fields needed to create an entity identifier.
    input: CreateEntityIdentifier!
  ): EntityIdentifier
  updateEntityIdentifier(
    # Fields required to update an entity identifier.
    input: UpdateEntityIdentifier!
  ): EntityIdentifier
  # Delete an entity identifier
  deleteEntityIdentifier(
    # Supply the ID of the entity identifier to delete.
    id: ID!
  ): DeletePayload
  # Create a library engine model.
  createLibraryEngineModel(
    # Fields required to create a library engine model.
    input: CreateLibraryEngineModel!
  ): LibraryEngineModel # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Update a library engine model
  updateLibraryEngineModel(
    # Fields required to update a library engine model
    input: UpdateLibraryEngineModel!
  ): LibraryEngineModel # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Delete a library engine model
  deleteLibraryEngineModel(
    # Supply the ID of the library engine model to delete.
    id: ID!
  ): DeletePayload
  # Apply an application workflow step, such as "submit" or "approve"
  applicationWorkflow(
    # Fields required to apply a application workflow step
    input: ApplicationWorkflow
  ): Application
    # @scopes(scopes: ["developer.engine.update"])
    # @audit(action: Update)
  # Apply an application workflow step, such as "submit" or "approve"
  engineWorkflow(
    # Fields required to apply a engine workflow step
    input: EngineWorkflow
  ): Engine # @scopes(scopes: ["developer.engine.update"]) # @audit(action: Update)
  # Create an ingestion configuration
  createIngestionConfiguration(
    input: CreateIngestionConfiguration
  ): IngestionConfiguration
    # @scopes(scopes: ["ingestion.create", "cms.workflows.create"], require: Any)
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Update an ingestion configuration
  updateIngestionConfiguration(
    input: UpdateIngestionConfiguration
  ): IngestionConfiguration
    # @scopes(scopes: ["ingestion.update", "cms.workflows.update"], require: Any)
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Delete an ingestion configuration
  deleteIngestionConfiguration(
    # ID of the ingestion configuration to delete
    id: ID!
  ): DeletePayload
    # @scopes(scopes: ["ingestion.delete", "cms.workflows.delete"], require: Any)
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Creates a widget associated with a collection
  createWidget(
    # Fields needed to create a new widget
    input: CreateWidget
  ): Widget # @scopes(scopes: ["collections.collections.create"])
  # Updates a widget
  updateWidget(
    # Fields needed to update a widget
    input: UpdateWidget
  ): Widget # @scopes(scopes: ["collections.collections.update"])
  # Create a new user within an organization.
  createUser(
    # Fields needed to create a user.
    input: CreateUser
  ): User # @scopes(scopes: ["admin.user.create"])
  # Create a new organization.
  createOrganization(
    # Fields needed to create an organization.
    input: CreateOrganization!
  ): Organization # @scopes(scopes: ["superadmin"])
  # Update an existing user
  updateUser(
    # Fields needed to update a user
    input: UpdateUser
  ): User # @scopes(scopes: ["admin.user.update"])
  # Force a user to update password on next login.
  # This mutation is used by administrators.
  createPasswordUpdateRequest(
    # Fields needed to create a password update request
    input: CreatePasswordUpdateRequest
  ): User # @scopes(scopes: ["admin.user.update"])
  # Get password token info for current user
  getCurrentUserPasswordToken(
    input: GetCurrentUserPasswordToken!
  ): PasswordTokenInfo! # @tokenType(type: User)
  # Create a password reset request. This mutation is used on behalf
  # of a user who needs to reset their password. It operates only on
  # the currently authenicated user (based on the authentication token provided).
  createPasswordResetRequest(
    input: CreatePasswordResetRequest
  ): CreatePasswordResetRequestPayload # @noAuth
  # Update the current authenticated user
  updateCurrentUser(input: UpdateCurrentUser!): User! # @tokenType(type: User)
  # Get password token info for current user
  getCurrentUserPasswordToken(
    input: GetCurrentUserPasswordToken!
  ): PasswordTokenInfo! # @tokenType(type: User)
  # Change the current authenticated user's password
  changePassword(
    # Fields needed to change password
    input: ChangePassword!
  ): User # @tokenType(type: User) # @audit(action: Update)
  # Delete a user
  deleteUser(
    # Supply the ID of the user to delete.
    id: ID!
  ): DeletePayload # @scopes(scopes: ["admin.user.delete"])
  # Create a structured data registry schema metadata.
  createDataRegistry(input: CreateDataRegistry!): DataRegistry
  # Update a structured data registry schema metadata.
  updateDataRegistry(input: UpdateDataRegistry!): DataRegistry
  # Update a structured data registry schema.
  upsertSchemaDraft(input: UpsertSchemaDraft!): Schema # @audit(action: Update)
  updateSchemaState(input: UpdateSchemaState!): Schema
  # Create (ingest) a structured data object
  createStructuredData(input: CreateStructuredData!): StructuredData
    # @auth(allowOrgless: true, skipObjectAuthorization: true)
  # Create (ingest) a structured data object
  createCollection(
    # Fields required to create new collection
    input: CreateCollection
  ): Collection # @scopes(scopes: ["collections.collections.create"])
  # Update a collection
  updateCollection(
    # Fields needed to update a collection
    input: UpdateCollection
  ): Collection # @scopes(scopes: ["collections.collections.update"])
  # Delete Collection
  deleteCollection(
    # # @deprecated(reason: "folderId has been renamed to id. Use id.")
    folderId: ID
    # Supply the ID of the folder or collection to delete
    id: ID
  ): DeletePayload # @scopes(scopes: ["collections.collections.delete"])
  # Share a collection, allowing other organizations to view the data
  # it contains.
  shareCollection(
    # Fields needed to share a collection
    input: ShareCollection
  ): Share # @scopes(scopes: ["collections.collections.share"])
  # Share a mention from a collection
  shareMentionFromCollection(
    # Fields needed to share a mention
    input: ShareMentionFromCollection
  ): Share # @scopes(scopes: ["collections.mentions.share"])
  # Add a mention to a collection
  createCollectionMention(
    # Fields needed to add a mention to a collection
    input: CollectionMentionInput
  ): CollectionMention # @scopes(scopes: ["collections.mentions.create"])
  # Remove a mention from a collection
  deleteCollectionMention(
    # Fields needed to delete a mention from a collection
    input: CollectionMentionInput
  ): CollectionMention # @scopes(scopes: ["collections.mentions.delete"])
  # Create a new folder
  createFolder(
    # Fields needed to create a new folder.
    input: CreateFolder
  ): Folder
    # @scopes(
      scopes: ["collections.collections.create", "cms.media.create"]
      require: Any
    )
  # Update an existing folder
  updateFolder(
    # Fields needed to update a folder.
    input: UpdateFolder
  ): Folder
    # @scopes(
      scopes: ["collections.collections.update", "cms.media.update"]
      require: Any
    )
  # Move a folder from one parent folder to another.
  moveFolder(
    # Fields needed to move a folder
    input: MoveFolder
  ): Folder
    # @scopes(
      scopes: ["collections.collections.update", "cms.media.update"]
      require: Any
    )
  # Delete a folder
  deleteFolder(
    # Fields needed to delete a folder
    input: DeleteFolder
  ): DeletePayload
    # @scopes(
      scopes: ["collections.collections.delete", "cms.media.delete"]
      require: Any
    )
  # Create a mention comment
  createMentionComment(
    # Fields needed to create a mention comment
    input: CreateMentionComment
  ): MentionComment # @scopes(scopes: ["collections.mentions.update"])
  # Update a mention comment
  updateMentionComment(
    # Fields needed to update a mention comment
    input: UpdateMentionComment
  ): MentionComment # @scopes(scopes: ["collections.mentions.update"])
  # Delete a mention comment
  deleteMentionComment(
    # Fields needed to delete a mention comment
    input: DeleteMentionComment
  ): DeletePayload # @scopes(scopes: ["collections.mentions.update"])
  # Create a mention rating
  createMentionRating(
    # Fields needed to create a mention rating
    input: CreateMentionRating
  ): MentionRating # @scopes(scopes: ["collections.mentions.update"])
  # Update a mention rating
  updateMentionRating(
    # Fields needed to update a mention rating
    input: UpdateMentionRating
  ): MentionRating # @scopes(scopes: ["collections.mentions.update"])
  # Delete a mention rating
  deleteMentionRating(
    # Fields needed to delete a mention rating.
    input: DeleteMentionRating
  ): DeletePayload # @scopes(scopes: ["collections.mentions.update"])
  # Login as a user. This mutation does not require an existing authentication
  # context (via `Authorization` header with bearer token, cookie, etc.).
  # Instead, the client supplies credentials to this mutation, which then
  # authenticates the user and sets up the authentication context.
  # The returned tokens can be used to authenticate future requests.
  userLogin(
    # Fields needed to log in
    input: UserLogin
  ): LoginInfo # @noAuth
  # Logout user and invalidate user token
  userLogout(
    # User token that should be invalidated
    token: String!
  ): Boolean
  # Refresh a user token, returning a fresh token so that the client
  # can continue to authenticate to the API.
  refreshToken(token: String!): LoginInfo
  # Validate a user token. This mutation is used by services to determine
  # if the token provided by a given client is valid.
  validateToken(token: String!): LoginInfo
  # Create a mention object
  createMention(input: CreateMention!): Mention
  # Create root folder for an organization
  createRootFolders(
    # The type of root folder to create
    rootFolderType: RootFolderType = watchlist
  ): [Folder]
    # @scopes(
      scopes: ["collections.collections.create", "cms.media.create"]
      require: Any
    )
  # Apply bulk updates to watchlists.
  # This mutation is currently available only to Veritone operations.
  bulkUpdateWatchlist(
    # A filter indicating which watchlists should be updated.
    # At least one filter condition must be provided.
    # Only watchlists for the user's organization will be updated.
    filter: BulkUpdateWatchlistFilter!
    # Fields used to update a watchlist.
    input: BulkUpdateWatchlist
  ): WatchlistList # @scopes(scopes: ["superadmin"])
  # File a TemporalDataObject in a folder. A given TemporalDataObject can
  # be filed in any number of folders, or none. Filing causes the TemporalDataObject
  # and its assets to be visible within the folder.
  fileTemporalDataObject(
    # The fields needed to file a TemporalDataObject in a folder
    input: FileTemporalDataObject!
  ): TemporalDataObject
    # @scopes(scopes: ["discovery.access", "recording.read"])
    # @auth(
      allowOrgless: true
      objectAuthType: TemporalDataObject
      objectAuthIdParam: "input.tdoId"
    )
  # Unfile a TemporalDataObject from a folder. This causes the TemporalDataObject
  # and its assets to disappear from the folder, but does not otherwise affect
  # either the TDO or the folder and does not change access controls.
  unfileTemporalDataObject(
    # The fields needed to file a TemporalDataObject in a folder
    input: UnfileTemporalDataObject!
  ): TemporalDataObject # @scopes(scopes: ["discovery.access", "recording.read"])
  # Moves a TemporalDataObject from one parent folder to another.
  # Any other folders the TemporalDataObject is filed in are unaffected.
  moveTemporalDataObject(
    # Fields need to move a TemporalDataObject
    input: MoveTemporalDataObject!
  ): TemporalDataObject # @scopes(scopes: ["recording.read"])
  # Upload and store an engine result. The result will be stored as an
  # asset associated with the target TemporalDataObject and the
  # task will be updated accordingly.
  # Use a multipart form POST to all this mutation.
  uploadEngineResult(
    # Fields needed to upload and store an engine result
    input: UploadEngineResult!
  ): Asset
    # @scopes(scopes: ["task.update"])
    # @auth(
      allowOrgless: true
      objectAuthType: Task
      objectAuthIdParam: "input.taskId"
    )
    # @audit(action: Create)

  createWatchlist(input: CreateWatchlist!): Watchlist

  updateWatchlist(input: UpdateWatchlist!): Watchlist

  deleteWatchlist(id: ID!): DeletePayload

  updateCognitiveSearch(input: UpdateCognitiveSearch): CognitiveSearch

  createCognitiveSearch(input: CreateCognitiveSearch): CognitiveSearch

  deleteCognitiveSearch(id: ID!): DeletePayload

  fileWatchlist(input: FileWatchlist!): Watchlist

  unfileWatchlist(input: UnfileWatchlist!): Watchlist

  # Share a folder with other organizations
  shareFolder(input: ShareFolderInput): Folder # @scopes(scopes: ["superadmin"])
  # Create a TDO and an asset with a single call
  createTDOWithAsset(
    # Input fields necessary to create the TDO and asset
    input: CreateTDOWithAsset
  ): TemporalDataObject # @scopes(scopes: ["recording.create"])

  createSubscription(input: CreateSubscription!): Subscription

  updateSubscription(input: UpdateSubscription!): Subscription

  deleteSubscription(id: ID!): DeletePayload

  # Create trigger for events or types.
  createTriggers(input: CreateTriggers!): [Trigger]

  # Delete a registed trigger by ID.
  deleteTrigger(id: ID!): DeletePayload

  # Validates if an engine output conforms to the engine output guidelines
  validateEngineOutput(input: JSONData!): Boolean!

  # JWT tokens with a more limited scoped token to specific
  # resources to the recording, task, and job
  # and also has no organization association.
  getEngineJWT(input: getEngineJWT!): JWTTokenInfo!
    # @scopes(
      scopes: ["task_type.internal", "task.update", "superadmin"]
      require: Any
    )

  # Verify JWT token
  verifyJWT(jwtToken: String!): VerifyJWTPayload
    # @auth(allowOrgless: true, skipObjectAuthorization: true)

  # Create a new Saved Search
  createSavedSearch(input: CreateSavedSearch!): SavedSearch!

  # Delete a saved search
  deleteSavedSearch(id: ID!): DeletePayload!

  # Mark existing saved search profile as deleted
  # Create new saved search profile
  replaceSavedSearch(input: ReplaceSavedSearch!): SavedSearch!

  # Send a basic email. Mutation returns true for a success message.
  sendEmail(input: SendEmail!): Boolean!

  # Create new content template into a folder
  createFolderContentTempate(
    input: CreateFolderContentTempate!
  ): FolderContentTemplate!

  # Update existing content template by folderContentTemplateId
  updateFolderContentTempate(
    input: UpdateFolderContentTempate!
  ): FolderContentTemplate!

  # Delete existing folder content template by folderContentTemplateId
  deleteFolderContentTempate(
    # Folder Content Template Id
    id: ID!
  ): DeletePayload!

  # Create an export request. The requested TDO data, possibly including
  # TDO media and engine results, will be exported offline.
  createExportRequest(
    # Input data required to create the export request
    input: CreateExportRequest!
  ): ExportRequest!

  # Update an export request
  updateExportRequest(
    # Input data required to update an export request
    input: UpdateExportRequest!
  ): ExportRequest!

  # Create Mention in bulk. The input should be an array of createMentions
  createMentions(input: CreateMentions!): MentionList

  # Create or Update Workflow data.
  setWorkflowRuntimeStorageData(
    workflowRuntimeId: ID!
    input: CreateWorkflowRuntimeStorageData!
  ): WorkflowRuntimeStorageData!
    # @scopes(
      scopes: ["superadmin", "veritone.superadmin", "workflow.create"]
      require: Any
    )

  # Create a new event
  createEvent(input: CreateEvent!): Event!

  # Update an event
  updateEvent(input: UpdateEvent!): Event!

  # Subscribe to an event
  subscribeEvent(input: SubscribeEvent!): ID!

  # Unsubscribe to an event
  unsubscribeEvent(id: ID!): UnsubscribeEvent!

  # Emit an event
  emitEvent(input: EmitEvent!): EmitEventResponse!

  # Start a Veritone Workflow instance
  startWorkflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!
    # @scopes(
      scopes: ["superadmin", "veritone.superadmin", "admin.org.update"]
      require: Any
    )

  # Shutdown Veritone Workflow instance
  stopWorkflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!
    # @scopes(
      scopes: ["superadmin", "veritone.superadmin", "admin.org.update"]
      require: Any
    )

  # Create a processTemplate in CMS
  createProcessTemplate(input: CreateProcessTemplate!): ProcessTemplate!
    # @scopes(scopes: ["cms.workflows.create"])

  # Update a processTemplate by ID in CMS
  updateProcessTemplate(input: UpdateProcessTemplate!): ProcessTemplate!
    # @scopes(scopes: ["cms.workflows.update"])
}

input CreateProcessTemplate {
  name: String!
  taskList: JSONData!
}

input UpdateProcessTemplate {
  id: ID!
  taskList: JSONData!
}

enum UpdateJobsStatus {
  queued
}

input UpdateJobs {
  ids: [ID!]
  status: UpdateJobsStatus
}

input CreateMentions {
  mentions: [CreateMention!]
}

input CreateFolderContentTempate {
  # The ID of folder
  folderId: ID!
  # The ID of Structure Data Object
  sdoId: ID!
  # The ID of Data Registry
  schemaId: ID!
  data: JSONData
}

input UpdateFolderContentTempate {
  # The ID of Folder Content Template
  id: ID!
  # The ID of folder
  folderId: ID
  # The ID of Structure Data Object
  sdoId: ID
  # The ID of Data Registry
  schemaId: ID
  data: JSONData
}

type SavedSearch {
  id: ID!
  organizationId: ID!
  organization: Organization # @scopes(scopes: ["admin.org.read"])
  ownerId: ID!
  owner: User
  name: String!
  sharedWithOrganization: Boolean
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  csp: JSONData
}

input CreateSavedSearch {
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSONData!
}

input ReplaceSavedSearch {
  id: ID!
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSONData!
}

type CreatePasswordResetRequestPayload {
  message: String
}

input getEngineJWT {
  # The ID of the engine that created the asset
  engineId: ID!
  # The set of IDs by resource type
  resource: GetEngineJWTResource!
}

input GetEngineJWTResource {
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

input ChangePassword {
  # The current user's old password. Must be provided even if the
  # user is otherwise authenticated as an additional security check.
  oldPassword: String!
  # The new password. May be subject to validation rules depending
  # on the organization or environment system policy.
  newPassword: String!
}

input CreateSubscription {
  # ID of the object (probably a watchlist) to create a subscription for
  targetId: ID!
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

# Used to create a subscription while creating a watchlist.
# The subscription will be for the new watchlist.
input CreateSubscriptionInWatchlist {
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

input CreateSubscriptionContact {
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

input UpdateSubscription {
  id: ID!
}

input FileWatchlist {
  # ID of the TDO to file
  watchlistId: ID!
  # ID of the new parent folder
  folderId: ID!
  # Order index determining in what order the watchlist will be displayed
  # relative to other objects at the same level
  orderIndex: Int = 0
}

input UnfileWatchlist {
  # ID of the watchlist to unfile
  watchlistId: ID!
  # ID of the parent folder. The watchlist will be removed from this folder.
  folderId: ID!
}

input ShareFolderInput {
  # The treeObjectId of the Folder to share
  treeObjectId: ID!
  # The organizations that will have read permissions to the Folder
  readOrganizationIds: [Int]
  # The organizations that will have write permissions to the Folder
  writeOrganizationIds: [Int]
}

input CreateTDOWithAsset {
  # TDO status, such as "recorded" (the default)
  status: String = "recorded"
  # A name for the TDO object, such as the name of the primary media file.
  name: String
  # Start date and time for the file
  startDateTime: DateTime!
  # Stop date and time. If not passed, the server
  # will apply a value based on the default
  # chunk size of 15 minutes.
  stopDateTime: DateTime
  # The ingestion source ID for this file
  sourceId: ID
  # Content type for the file.
  # Default is "video/mp4"
  contentType: String = "video/mp4"
  # The file location or URI.
  uri: String
  file: UploadedFile
  # Deprecated - use scheduledJobId
  scheduleId: ID # @deprecated(reason: "use scheduledJobId")
  # The scheduled job ID.
  scheduledJobId: ID
  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean
  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID
  # Asset type. Default is "media".
  assetType: String = "media"

  # Optionally, set source data for this TDO. Source data identifies
  # that task that generated this TDO. If the TDO was not generated as part
  # of engine or adapter execution, this field should not be set.
  # However, it is _strongly_ recommended that engines that create TDOs
  # set this field. Doing so ensures that later tasks in the same job
  # have appropriate access to the new TDO.
  # This source data will be set on both the TDO and the asset.
  sourceData: SetTDOSourceData

  details: JSONData

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String
  # An optional image representing the TDO source
  sourceImageUrl: String
}

input FileTemporalDataObject {
  # ID of the TDO to file
  tdoId: ID!
  # ID of the new parent folder
  folderId: ID!
  # Order index determining in what order the new TDO will be displayed
  # relative to other TDOs at the same level
  orderIndex: Int = 0
}

input UnfileTemporalDataObject {
  # ID of the TDO to unfile
  tdoId: ID!
  # ID of the parent folder. The TDO will be removed from this folder.
  folderId: ID!
}

input MoveTemporalDataObject {
  # ID of the TDO to move
  tdoId: ID!
  # ID of the original parent folder. The TDO will be removed from this folder.
  oldFolderId: ID!
  # ID of the new parent folder. The TDO will be added to this folder.
  newFolderId: ID!
}

# Fields needed to upload and store an engine result using multipart form POST.
input UploadEngineResult {
  # ID of the task that created this engine result
  taskId: ID!
  # A string containing the engine result.
  # Use either this field, `output`, or `file` with multipart form POST, but not
  # more than one.
  outputString: String
  # JSON data containing the engine result.
  # A string containing the engine result.
  # Use either this field, `outputString`, or `file` with multipart form POST, but not
  # more than one.
  output: JSONData
  # A file to upload. Use multipart form POST to submit this field.
  # Use either this field or the `outputString` field, not both.
  file: UploadedFile
  # The file name
  filename: String
  # The type of asset to create. Optional -- if not set, it will be
  # deduced from the engine category.
  assetType: String
  # The content type of the file. Optional -- if not set, it will
  # be deduced from the file name.
  contentType: String
  # Whether or not to mark the task as complete. Defaults to true.
  completeTask: Boolean = true
  # If the result data uploaded is not a valid JSON string, then
  # the task output data stored on the task object will be wrapped into
  # a JSON object using this key. The asset created, however, is not
  # modified in any way.
  outputJsonKey: String = "data"
  # Optionally, set attributes about the file
  fileData: SetAssetFileData
  # if true, sets the new asset to be the primary asset of its type.
  # Only certain asset types, such as "media" and "transcript",
  # can have primary assets.
  setAsPrimary: Boolean = false
  # Skips indexing the engine result, preventing mentions from being
  # generated over the results.
  skipIndexing: Boolean = false
  # Whether or not to set the legacy `task_output` data for compatible
  # with older clients.
  setTaskOutput: Boolean = true
}

# Input fields required by the userLogin mutation.
input UserLogin {
  # The user login name -- typically, email address.
  userName: String!
  # The user password. Note that this value is only ever transmitted over
  # the encrypted SSL protocol.
  password: String!
}

# Contains information about engineJWTToken context
type JWTTokenInfo {
  engineId: ID!
  token: String!
  resource: EngineJWTResource!
}

# Contain resouces of Engine JWT Token
type EngineJWTResource {
  applicationId: ID
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

# Contains information about the user's authentication context.
type LoginInfo {
  # API token. This is a persistent organization-level token intended for API access.
  apiToken: String
  # Session-scoped user token. This token is tied to the user's session and will expire
  # when that session ends.
  token: String
  # Date and time at which the user last logged in to the Veritone platform
  lastLoggedIn: String
  # List of Veritone platform applications for which the user is provisioned.
  # Note that these are different than the VDA custom applications referenced
  # in the `Application` type, `applications()` query, and related mutations.
  applications: [ID]
  applicationPlatforms: [ApplicationPlatform]
  # Groups to which the user belongs.
  groups: [Group]
  # True if the user account has a password set. False otherwise.
  # If false, the user will be prompted to set a password on next login.
  hasPassword: Boolean
  # Organization to which the user belongs.
  organization: Organization
  # True if a password reset will be required on the user's next login.
  passwordResetRequired: Boolean
  # TODO
  providerId: String
  # TODO
  providerScreenName: String
  # TODO
  providerUserId: String
  # User object
  user: User
}

type Token {
  # The token ID
  id: String
  applicationId: String
  groupId: String
  json: TokenJson
}

type TokenJson {
  rights: [String]
}

# TODO
type ApplicationPlatform {
  # The application platform ID
  id: ID
  # Platform type, such as TODO
  platformType: String
  # The application platform URL.
  platformUrl: String
}

# Options used by the cleanupTDO mutation to select which data is deleted.
enum TDOCleanupOption {
  # Indicates that all assets should be deleted from storage, including
  # those used to store engine results. Metadata about the assets will remain
  # until the container TemporalDataObject is permanently deleted.
  storage
  # Indicates that all search index data should be deleted. The TemporalDataObject
  # and its assets will no longer be accessible through search.
  searchIndex
  # Indicates that engine results stored on related task objects should be deleted.
  # Engine results stored as assets will remain until assets are removed
  # using the storage option.
  engineResults
}

# Information required to create a new folder.
# After creation, a folder can be renamed with the `updateFolder` mutation,
# but no other changes are supported.
input CreateFolder {
  # The folder name
  name: String!
  # The folder description
  description: String!
  # ID of the parent folder underneath which the new folder will be placed.
  parentId: ID!
  # Root folder type to apply to the new folder
  rootFolderType: RootFolderType
  # Order index determining in what order the new folder will be displayed
  # relative to other folders at the same level.
  orderIndex: Int = 0
}

# Information required to update a folder.
# Currently, the folder can be renamed. No other changes are supported.
input UpdateFolder {
  # ID of the folder to update
  id: ID!
  # New name for the folder.
  name: String!
}

# Move a folder into a new parent folder.
input MoveFolder {
  #
  treeObjectId: ID!
  prevParentTreeObjectId: ID!
  newParentTreeObjectId: ID!
  newOrderIndex: Int!
  prevOrderIndex: Int!
  rootFolderType: RootFolderType = watchlist
}

# Delete a folder
input DeleteFolder {
  # ID of the folder to delete
  id: ID!
  orderIndex: Int!
}

# Set of possible states for a custom application.
# The application state determines whether or not it is available in production
# and the actions that can be taken on it.
enum ApplicationStatus {
  # The application is active (production state)
  active
  # The application is in draft state during test and development
  draft
  # The application has been deleted and is no longer available for any purpose
  deleted
  # The application is awaiting approval.
  pending
  # The application has been rejected and must be modified and re-submitted.
  rejected
  # The application has been approved and can now be deployed.
  approved
  # The application has been disabled, but not deleted.
  disabled
}

# Deployment models describe how an engine or application operates on the network
# and where the data it works with is transmitted. See Veritone's developer
# documentation at https://steel-ventures.atlassian.net/wiki/spaces/VDH/pages/101364981/Engine+Deployment+Models
# for a full description.
enum DeploymentModel {
  # The engine or application is fully isolated and does not call out to any
  # external endpoints. Numerical code 0.
  FullyNetworkIsolated
  # The engine or application does not transmit data about its payload over the internet,
  # but may still make external network calls for limited purposes. Numerical code 1.
  MostlyNetworkIsolated
  # The engine or application is not network isolated and must call out to external services
  # and transmit data about its payload. Numerical code 2.
  NonNetworkIsolated
  # Human review of engine results is required. Numerical code 3.
  HumanReview
}

# Common fields used by queries and fields that support paging to represent
# a single page of results.
interface Page {
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

# Payload required to create a temporal data object
input CreateTDO {
  # Start date and time in numerical (epoch) format.
  startDateTime: DateTime!
  # Stop date and time in numerical (epoch) format.
  stopDateTime: DateTime!
  # Source for the TDO, such as an ingestion type or engine ID.
  source: String
  # Status, such as "downloaded" or "recording".
  # The server will set a value if one is not provided.
  status: String = "downloaded"
  # A name for the TDO object, such as the name of the primary media file.
  name: String
  # A description for the TDO object.
  description: String
  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean
  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID

  # Optionally, set source data for this TDO. Source data identifies
  # that task that generated this TDO. If the TDO was not generated as part
  # of engine or adapter execution, this field should not be set.
  # However, it is _strongly_ recommended that engines that create TDOs
  # set this field. Doing so ensures that later tasks in the same job
  # have appropriate access to the new TDO.
  sourceData: SetTDOSourceData

  details: JSONData

  # Only internal systems can set this value
  applicationId: ID

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String
  # An optional image representing the TDO source
  sourceImageUrl: String
}

# Payload required to create a temporal data object
input UpdateTDO {
  # ID of the TDO to update
  id: ID!
  # Start date and time in numerical (epoch) format.
  startDateTime: DateTime
  # Stop date and time in numerical (epoch) format.
  stopDateTime: DateTime
  # Source for the TDO, such as an ingestion type or engine ID.
  source: String
  # Current status, such as "downloaded" or "recording".
  status: String
  # A name for the TDO object, such as the name of the primary media file.
  name: String
  # A description for the TDO object.
  description: String
  # Set the primary asset of a given type (transcript or media)
  primaryAsset: [SetPrimaryAsset!]
  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean

  details: JSONData

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  # Setting this field on an update does _not_ affect any content templates
  # previously added to the TDO -- it only creates the new ones.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String
  # An optional image representing the TDO source
  sourceImageUrl: String
}

input CreateTDOContentTemplateWithTDO {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!
  # To associate an existing structured data object (SDO) to the
  # TDO, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID
  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSONData
}

# Input used to set the primary asset of a given type on a TDO.
# The type must be supported by the server; primary asset is used
# by certain engines and front end components.
# Currently "media" and "transcript" are supported.
input SetPrimaryAsset {
  # ID of the asset
  id: ID!
  # The asset type -- "media" or "transcript"
  assetType: String!
}

input RequestClone {
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  cloneBlobs: Boolean = false
}

input CreateWidget {
  widgetId: String
  collectionId: ID!
  organizationId: String
  folderId: String
  name: String
  adScript: String
  width: Int
  numberOfMentionsToShow: Int
  displayLogo: Boolean
  displayCollectionName: Boolean
  displayMentionIntro: Boolean
  displayTranscription: Boolean
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
}

input UpdateWidget {
  id: ID
  widgetId: String
  name: String
  organizationId: ID
  collectionId: ID!
  displayCollectionName: Boolean
  displayTranscription: Boolean
  width: Int
  numberOfMentionsToShow: Int
  adScript: String
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  createdDateTime: DateTime
  displayLogo: Boolean
  displayMentionIntro: Boolean
}

input CreateApplication {
  name: String!
  key: String!
  category: String
  description: String!
  iconUrl: String
  iconSvg: String
  url: String!
  oauth2RedirectUrls: [String]
  checkPermissions: Boolean!
  permissionsRequired: [String]
  deploymentModel: DeploymentModel
  contextMenuExtensions: CreateContextMenuExtensions
}

input UpdateApplication {
  id: ID!
  name: String
  status: ApplicationStatus
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  oauth2RedirectUrls: [String!]
  checkPermissions: Boolean
  permissionsRequired: [String!]
  deploymentModel: DeploymentModel
  contextMenuExtensions: UpdateContextMenuExtensions
}

input ApplicationWorkflow {
  id: ID!
  action: ApplicationWorkflowAction!
}

enum ApplicationWorkflowAction {
  submit
  approve
  reject
  deploy
  enable
  disable
  undelete
}

### Base metadata types

interface Metadata {
  name: String!
}

# Key-value pairs -- a generic way to represent metadata
type KVP implements Metadata {
  name: String!
  value: [Property]
}

# A property is a name-value pair. This is the base interface for properties.
interface Property {
  name: String!
}

# Type representing an integer property.
type IntProperty implements Property {
  name: String!
  value: Int
}

# Type representing a string property
type StringProperty implements Property {
  name: String!
  value: String
}

# Type representing a boolean property
type BooleanProperty implements Property {
  name: String!
  value: Boolean
}

type CompoundProperty implements Property {
  name: String!
  value: KVP
}

# Payload required to delete an object
type DeletePayload {
  # ID of the object that was deleted
  id: ID!
  # a message
  message: String
}

#### TDOs, assets, and clone requests

type CloneRequest {
  id: ID!
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  numberOfRecordings: Int
  numberOfCompletedRecordings: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: String
  percentage: Int
}

type CloneRequestList implements Page {
  records: [CloneRequest]
  count: Int
  offset: Int!
  limit: Int!
}

enum AssetOrderBy {
  createdDateTime
  assetType
  contentType
}

type TemporalDataObject {
  # Object creation timestamp. Does not change. In seconds since epoch (TODO change!).
  createdDateTime: DateTime
  # Object modification timestamp. In seconds since epoch (TODO change!).
  modifiedDateTime: DateTime
  # The object's unique ID
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String
  mediaId: ID

  # An optional URL for a thumbnail or preview image for
  # this object. If the URL is to an object in Veritone's
  # object storage, it will be signed.
  thumbnailUrl: String

  # An optional URL for a source image for this object.
  # If the URL is to an object in Veritone's
  # object storage, it will be signed.
  sourceImageUrl: String

  # Modular metadata
  metadata: [Metadata]
  # Direct access to metadata in raw JSON format
  jsondata: JSONData

  details(
    # optionally, specify a path to retrieve only a specific property
    # within the details JSON
    path: String
  ): JSONData

  # Assets this object contains. Can be of any size.
  # This field does not support paging.
  assets(
    # Provide an ID to retrieve a single asset.
    id: ID
    # Specify a list of asset types such as "media" or "transcript" to
    # retrieve a specific asset type
    type: [String!]
    # Deprecated -- use type parameter
    assetType: [String!] # @deprecated(reason: "use _type_ parameter")
    # Retrieve assets created by a specific task
    sourceTaskId: ID
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    orderBy: AssetOrderBy = createdDateTime
    orderDirection: OrderDirection = desc
  ): AssetList
  # Retrieve the primary asset of a given type
  primaryAsset(assetType: String!): Asset
  # Security settings for the asset container
  security: Security
  # Recording start time. In seconds since epoch.
  startDateTime: DateTime!
  # Recording stop time. In seconds since epoch.
  stopDateTime: DateTime!
  source: String
  name: String
  # Application this recording belongs to
  applicationId: ID!
  # status. Downloaded, recording, etc.
  status: String
  # Tasks running against this TemporalDataObject
  tasks(
    id: ID
    offset: Int = 0
    limit: Int = 30
    hasSourceAsset: Boolean
  ): TaskList
  # Jobs running against this temporalDataObject
  jobs: JobList
  # Folders that this TDO is filed in
  folders: [Folder!]

  sourceData: TDOSourceData

  # If this TDO supports streams, contains stream listings.
  # Might be an empty list but will not be null.
  streams: [TDOStreamData!]!

  # Statuses of the engines run on the TDO.
  engineRuns(offset: Int = 0, limit: Int = 100): EngineRunList
}

# Describes a stream that is available on a TDO
type TDOStreamData {
  # The stream URI
  uri: String!
  # The protocol, such as "dash" or "hls"
  protocol: String!
}

# Describes engine run on a TDO with
type EngineRun {
  # Engine that was run on a TDO
  engine: Engine
  # Engine status derived from the written engine output or task status. See TaskStatus enum for details.
  status: TaskStatus
  # All in-flight tasks for the given engine
  activeTasks(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Maximum number of results to retrieve in this query
    limit: Int = 100
  ): TaskList
  # Whether or not the engine run has user edits
  hasUserEdits: Boolean
}

type EngineRunList implements Page {
  records: [EngineRun]
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
}

# Describes source information about a TDO. That is,
# the components and processes that produced it.
# Each field may or may not have a value, depending on
# how the TDO was created.
type TDOSourceData {
  # Task ID, typically of an ingestion task.
  taskId: ID
  # The task object.
  task: Task
  # Ingestion source ID
  sourceId: ID
  # ID of the scheduled job, if any, under which this TDO was created
  scheduledJobId: ID
  # ID of the engine used in the task that created this TDO
  engineId: ID
  # The engine used in the task that created this TDO.
  engine: Engine
}

type TDOList implements Page {
  records: [TemporalDataObject]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type VerifyJWTPayload {
  # the same JWT input
  jwtToken: String!
  # the payload contained within the JWT
  payload: JSONData!
}

# Contains security settings on an asset container
type Security {
  # Whether or not the object is globally visible
  global: Boolean
}

# Object that represents the mapping of clone assets to its parent's assets.
type CloneAssetIdMap {
  # The original asset ID (within the cloned asset container).
  oldAssetId: ID!
  # The new asset ID (within the clone asset container).
  newAssetId: ID!
}

# Metadata that represents a clone of a recording.
type CloneData implements Metadata {
  # Timestamp when the recording was cloned
  date: String
  # The ID of the asset container this was cloned from
  originalId: String!
  # Clone blobs flag
  cloneBlobs: Boolean
  # Map of asset IDs from the clone to the parent.
  assetIdMap(
    # Provide an ID to retrieve mappings for specific old asset.
    oldAssetId: ID
    # Provide an ID to retrieve mappings for a specific new asset.
    newAssetId: ID
  ): [CloneAssetIdMap]
  name: String!
}

# Metadata that represents a program.
type Program implements Metadata {
  id: ID
  name: String!
  image: String
  liveImage: String
}

type FileData implements Metadata {
  name: String!
  size: Int
  mimeType: String
  fileName: String
}

# An asset represents a single unit of data, such as a file or URL,
# and basic metadata about that data. An asset must be contained within
# a TemporalDataObject.
type Asset {
  # The asset ID
  id: ID!
  # Asset name, such as a file name.
  name: String
  # Asset content type. Must be a valid MIME type string.
  contentType: String
  # An optional description of the asset
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  # Freeform metadata in JSON format.
  jsondata: JSONData
  # The ID of the TemporalDataObject that contains this asset
  containerId: ID!
  # The TemporalDataObject that contains this asset
  container: TemporalDataObject
  # The asset's URI. If a file is provided on asset creation, this URI
  # point to the object in Veritone's object storage.
  uri: String ## @scopes(scopes: ["asset.uri"])
  # A signed version of the asset's URI
  signedUri: String ## @scopes(scopes: ["asset.uri"])
  # The asset type, such as `media`, `transcript`, or `text`.
  # The asset type determines which engines are able to operate on it.
  # For example, a transcription engine requires a `media` asset.
  # Engines that record their results in an asset typically set the type
  # accordingly, such as `transcript`.
  type: String!
  # Deprecated alias for type
  assetType: String
  # Freeform application-defined metadata. This field may contain information
  # specific to the object type, such as image or video metadata.
  details(
    # optionally, specify a path to retrieve only a specific property
    # within the details JSON
    path: String
  ): JSONData
  # Metadata as raw JSON string
  jsonstring(indent: Int = 2): String
  # A structured containing metadata about a file. This will be set if the
  # asset was created by uploading a file.
  fileData: AssetFileData
  # A structure containing metadata about the source engine and task. This will
  # be set if the asset was created by an engine.
  sourceData: AssetSourceData
  # Asset transform. The transformation function to be used with the asset.
  # It can be XML to JSON
  transform(transformFunction: TransformFunction!): String
  # A Boolean indicating whether or not this asset was created by editing
  # another asset.
  isUserEdited: Boolean
}

# A structured containing metadata about an asset file.
type AssetFileData {
  # The MD5 checksum of the file
  md5sum: String
  # The file size in bytes
  size: Int
  # Original file URI, if provided on asset creation
  originalFileUri: String
}

# Input type for AssetFileData
input SetAssetFileData {
  # The MD5 checksum of the file
  md5sum: String
  # The file size in bytes
  size: Int
  # Original file URI, if provided on asset creation
  originalFileUri: String
  # The insertion mode of the asset
  mode: AssetCreationMode = create
}

enum AssetCreationMode {
  create
  append
  replace
}

# A structure containing metadata about the source engine and task for an asset.
type AssetSourceData {
  # The name of the asset source engine or engine category
  name: String
  # ID of the specific task that created the asset
  taskId: ID
  # The specific task that created the asset
  task: Task # @scopes(scopes: ["task.read"])
  # The ID of the engine that created the asset
  engineId: ID
  # The engine that created the asset
  engine: Engine # @scopes(scopes: ["developer.engine.read"])
  # The ID of the source from which this asset was generated or stamped.
  sourceId: ID
  # ID of the schema describing this asset, if there is one.
  # Typically applies only to assets of type "content-template".
  schemaId: ID
  # The schema definition, if there is one
  schema: Schema
}

# Input type for AssetSourceData
input SetAssetSourceData {
  # The name of the asset source engine or engine category
  name: String
  # ID of the specific task that created the asset
  taskId: ID
  # ID of the engine that created the asset
  engineId: ID
  # Optional ID of the source from which this asset
  # was created. This field will typically be set only
  # by adapters that ingest data.
  sourceId: ID
  # Optional ID of the scheduled job that created this asset
  scheduledJobId: ID
  # Optional ID of the asset this asset was created from.
  # This will usually be assets with edits to a previous
  # asset.
  assetId: ID
}

# Identifies the task that created a TDO.
input SetTDOSourceData {
  # ID of the task that created this TDO
  taskId: ID
  # Optional ID of the source from which this TDO's initial
  # data was created. This field will typically be set only
  # by adapters that ingest data and create TDOs.
  sourceId: ID
  # Optional ID of the scheduled job that created this TDO.
  scheduledJobId: ID
}

input CreateTaskLog {
  # ID of the task which the task long belongs to.
  taskId: ID!
  # A file to upload. Use multipart form POST to submit this field.
  file: UploadedFile
}

type AssetList implements Page {
  records: [Asset]
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
}

input CreateAsset {
  # ID of the parent container, a TemporalDataObject, for the new asset
  containerId: ID!
  # A valid MIME type
  contentType: String
  # An optional description for the asset
  description: String
  # A file to upload. Use multipart form POST to submit this field.
  file: UploadedFile
  # Optional expected checksum for the file
  md5sum: String
  # Asset type - deprecated (use type)
  assetType: String # @deprecated(reason: "use `type` instead")
  # The asset type. Either this or assetType must be provided.
  type: String
  # URI to the asset data. Optional -- if a file is provided, the URI
  # will be computed by the server.
  uri: String
  # Optionally, set attributes about the file
  fileData: SetAssetFileData
  # Optionally, set attributes about the source engine and task
  sourceData: SetAssetSourceData
  # Application- or type-specific metadata
  details: JSONData
  # File or other name
  name: String
  # Deprecated. Set `fileData`, `sourceData`, or `details` instead.
  jsondata: JSONData

  # if true, sets the new asset to be the primary asset of its type.
  # Only certain asset types, such as "media" and "transcript",
  # can have primary assets.
  setAsPrimary: Boolean = false

  # Set to true if this asset was created by editing another asset.
  isUserEdited: Boolean = false
}

# Input needed to update an asset. The asset data itself -- file or URI --
# is immutable. Only supplemental metadata can be updated with this input type.
input UpdateAsset {
  # The asset ID. Required.
  id: ID!
  # The asset description.
  description: String
  # File name or other name for the asset
  name: String
  # Optionally, set attributes about the file
  fileData: SetAssetFileData
  # Optionally, set attributes about the source engine and task
  sourceData: SetAssetSourceData
  # Application- or type-specific metadata
  details: JSONData
}

####### Library and entity

type Entity {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  properties: [Property]
  libraryId: ID
  library: Library
  profileImageUrl: String
  identifiers(
    # Provide an ID to retrieve a specific entity identifier
    id: ID
    identifierTypeId: ID
    offset: Int = 0
    limit: Int = 30
  ): EntityIdentifierList
  isPublished: Boolean
  jsondata: JSONData
  jsonstring: String
  summary: EntitySummary
  description: String
}

type EntitySummary {
  identifierCountsByType: JSONData
}

input CreateEntity {
  name: String!
  description: String
  libraryId: ID!
  profileImageUrl: String
  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSONData
  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
  isPublished: Boolean = false
}

input UpdateEntity {
  id: ID!
  name: String
  description: String
  profileImageUrl: String
  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSONData
  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
}

type EntityIdentifierType {
  id: ID!
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
}

type EntityIdentifierTypeList implements Page {
  records: [EntityIdentifierType!]
  limit: Int!
  offset: Int!
  count: Int
}

enum EntityIdentifierDataType {
  image
  audio
  video
  text
  pdf
}

input CreateEntityIdentifierType {
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
  id: ID!
}

input UpdateEntityIdentifierType {
  id: ID!
  label: String
  labelPlural: String
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType
}

type EntityIdentifier {
  id: ID!
  entityId: ID!
  entity: Entity!
  identifierType: EntityIdentifierType!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  url: String!
  contentType: String!
  jsondata: JSONData
  jsonstring: String
}

type EntityIdentifierList implements Page {
  records: [EntityIdentifier]
  offset: Int!
  limit: Int!
  count: Int
}

input CreateEntityIdentifier {
  entityId: ID!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  url: String
  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSONData
  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
  contentType: String!
  file: UploadedFile
  entityType: CreateEntityType
  # If the entity identifier type is image, the new file can automatically
  # be set on the entity as its profile image. This is off by default
  # (the entity profile image is not modified) but can be controlled
  # with this parameter.
  profileUpdateMode: SetEntityProfileImage = none
}

# Settings that determine when to set a new entity identifier
# as the entity profile image.
enum SetEntityProfileImage {
  # Do not update the entity profile image
  none
  # Set the the entity identifier URL as the entity profile image
  # only if there is no current profile image. Will cause an error
  # if the entity identifier type is not an image.
  ifNotSet
  # Set the entity identifier as the new entity profile image,
  # overwriting whatever value is present. Will cause an error
  # if the entity identifier type is not an image.
  always
}

input UpdateEntityIdentifier {
  id: ID!
  title: String
  isPriority: Boolean
  url: String
  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSONData
  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
}

type LibraryType {
  id: ID!
  label: String
  iconClass: String
  entityIdentifierTypes: [EntityIdentifierType]
  entityTypeName: String
  entityTypeNamePlural: String
  entityType: EntityType
}

input CreateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: CreateEntityType!
}

input UpdateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: UpdateEntityType
}

type EntityType {
  name: String!
  namePlural: String!
  schema: JSONData!
}

input CreateEntityType {
  name: String!
  namePlural: String!
  schema: JSONData!
}

input UpdateEntityType {
  name: String
  namePlural: String
  schema: JSONData
}

type LibraryTypeList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
  records: [LibraryType]
}

enum OrderDirection {
  asc
  desc
}

enum LibraryOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
  version
}

enum LibraryEntityOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
}

type Library {
  # Object creation timestamp. Does not change.
  createdDateTime: DateTime
  # Object modification timestamp.
  modifiedDateTime: DateTime
  # The object's unique ID
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String
  # Modular metadata in the form of key-value pairs
  properties: [Property]
  # Security settings for the asset container
  security: Security
  applicationId: ID!
  # Library version
  version: Int
  organizationId: ID
  libraryType: LibraryType
  libraryTypeId: ID
  coverImageUrl: String
  # Retrieve engine models for a library
  engineModels(id: ID): LibraryEngineModelList
  entities(
    # Provide an ID to retrieve a single specific entity.
    id: ID
    ids: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList
  # Retrieve collaborators for a library.
  collaborators(
    # Provide an ID to retrieve collaborators within a specific organization.
    collaboratorOrgId: ID
  ): LibraryCollaboratorList
  # Aggregated summary data about the library
  summary: LibrarySummary
}

type LibrarySummary {
  entityCount: Int
  unpublishedEntityCount: Int
  lastTrainedVersion: Int
  lastTrainedDateTime: DateTime
}

input CreateLibrary {
  name: String!
  applicationId: ID
  organizationId: ID
  libraryTypeId: ID!
  coverImageUrl: String
  description: String
}

input UpdateLibrary {
  id: ID!
  name: String
  coverImageUrl: String
  description: String
  libraryTypeId: ID
  version: Int
}

type LibraryCollaborator {
  organizationId: ID!
  organization: Organization
  status: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  permissions: [String]
  libraryId: ID!
  library: Library
}

type LibraryCollaboratorList {
  records: [LibraryCollaborator]
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type LibraryEngineModel {
  id: ID!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  engineId: ID!
  engine: Engine
  libraryId: ID!
  library: Library
  libraryVersion: Int
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus!
  dataUrl: String
  # Content type of the data file pointed to by dataUrl.
  # Will be empty if no data file is attached to the engine model.
  contentType: String
  jsondata: JSONData
}

enum LibraryEngineModelTrainStatus {
  pending
  queued
  complete
  failed
  running
}

input CreateLibraryEngineModel {
  # ID of the engine the model is used by
  engineId: ID!
  # ID fo the library containing this engine model.
  libraryId: ID!
  # Id of the train job.
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus = pending
  # The URL to a file containing or related to the engine model.
  # Use this field if the data is stored in a separate, internet-accessible
  # location and not managed by Veritone APIs.
  # You may also use `updateLibraryEngineModel` to upload a data file.
  dataUrl: String
  # Optional free-form block containing engine-specific metadata.
  jsondata: JSONData
}

input UpdateLibraryEngineModel {
  # ID of the library engine model to update.
  id: ID!
  # Id of the train job.
  trainJobId: ID
  # Status of the train job.
  trainStatus: LibraryEngineModelTrainStatus
  # The URL to a file containing or related to the engine model.
  # Submit either this field _or_ `file`, not both.
  # Use this field if the data is stored in a separate, internet-accessible
  # location and not managed by Veritone APIs.
  dataUrl: String
  # Optional free-form block containing engine-specific metadata.
  jsondata: JSONData
  # If a file is uploaded, you can explicitly specify the content type
  # (a valid MIME type string) with this field. Often this is not necessary
  # as the HTTP multipart form POST client will set content type on the
  # file object implicitly.
  contentType: String
  # An optional data file containing or related to the engine model.
  # Use multipart form POST to submit this field.
  # Submit either this field _or_ `dataUrl`, not both. If a file is
  # uploaded, the server will store it and then set `dataUrl` to
  # its location.
  file: UploadedFile
}

type LibraryEngineModelList implements Page {
  records: [LibraryEngineModel]
  offset: Int!
  limit: Int!
  count: Int
}

type LibraryList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
  records: [Library]
}

type EntityList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
  records: [Entity]
}

######## job, task, engine APIs

type Engine {
  id: ID!
  ownerOrganizationId: ID!
  isPublic: Boolean
  logoPath: String
  iconPath: String
  # The signed URL for the engine icon; will fallback to raw iconPath if unable to sign.
  signedIconPath: String
  # The signed URL for the engine logo; will fallback to raw logoPath if unable to sign.
  signedLogoPath: String
  name: String
  ownerOrganization: Organization
  description: String
  categoryId: String
  state: EngineState
  price: Int
  asset: String
  displayName: String
  validateUri: String
  executeUri: String
  applicationId: ID
  # True if the engine creates a TemporalDataObject (TDO) as part of its
  # execution. False otherwise.
  createsTDO: Boolean
  website: String
  rating: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  # True if the engine requires a library to run. If so, a library ID must
  # be provided in the engine payload.
  libraryRequired: Boolean
  deploymentModel: DeploymentModel
  tasks(
    status: [String]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    id: ID
    dateTimeFilter: [TaskDateTimeFilter]
    hasSourceAsset: Boolean
  ): TaskList
  # Retrieve builds for the engine.
  # By default, deleted builds are not included.
  # Deleted builds can be retrieved by including the `deleted` status parameter.
  builds(
    buildStatus: [BuildStatus!]
    status: [String]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    id: ID
  ): BuildList

  # Dependency information for this engine
  dependency: EngineDependency

  # The list of custom fields on the engine. Users will be prompted to
  # set or change these values when they run the engine. For example, a
  # translation engine might have a field for the target language.
  fields: [EngineField!]
  # The engine category
  category: EngineCategory
  validStateActions: [EngineStateAction]

  # Get the engine's preferred input format, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  preferredInputFormat: String
  # Get the engine's supported input formats, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  supportedInputFormats: [String!]
  # Get the engine's output formats, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  outputFormats: [String!]
  # List of IDs of source types that the engine supports,
  # based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  # Applies only to adapter engines that ingest data from a source.
  # Will be a list of IDs of SourceType objects.
  supportedSourceTypes: [String!]
  # Get the ingestion flag which determines whether the adapter has a scan phase during ingestion.
  # If there is no deployed build this field cannot be populated.
  hasScanPhase: Boolean

  # Get the deployed build version of this engine. If there is no deployed
  # build, this field will be null.
  deployedVersion: Int

  # Specifies the mode in which the engine process input
  mode: EngineMode

  # Specifies the runtime type, such as "iron" or "edge"
  runtimeType: String

  # Get oauth information based on the deployed build. If there is no deployed
  # build, this field will be null.
  oauth: String

  # List of schedule types that the engine supports,
  # based on the latest deployed build.
  # If there is no deployed build, this field cannot be populated.
  supportedScheduleTypes: [EngineScheduleType!]

  # Retrieve task metrics for the engine
  taskMetrics(
    # Provide a starting date in ISO format (maximum range of 7 days)
    fromDateTime: DateTime
    # Provide an end date in ISO format (maximum range of 7 days)
    toDateTime: DateTime
  ): EngineTaskMetrics
}

type EngineTaskMetrics {
  cancelledCount: Int
  completedCount: Int
  failedCount: Int
  pendingCount: Int
  queuedCount: Int
  runningCount: Int
}

enum EngineMode {
  Chunk
  Stream
  Batch
}

enum EngineScheduleType {
  Now
  OnDemand
  Recurring
  Continuous
}

enum EngineStateAction {
  edit
  delete
  disable
  enable
  undelete
}

type EngineDependency {
  # TODO maps to values in engineCategory.data_field?
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String!
  # Asset type to expect previous engine to produce
  assetType: String
  # The engine category corresponding to this dependency
  category: EngineCategory
}

input CreateEngineDependency {
  # The category type this engine depends on.
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String!

  # An optional asset type that the engine will expect to have
  # been created.
  assetType: String
}

input UpdateEngineDependency {
  # The category type this engine depends on.
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String

  # An optional asset type that the engine will expect to have
  # been created.
  assetType: String
}

type EngineList implements Page {
  records: [Engine]
  # Number of records returned in this response
  count: Int!
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
}

# Input fields used to create a new engine.
input CreateEngine {
  # Indicates whether or not the engine should be public -- visible to and
  # usable by users outside the creator's organization.
  # Typically an engine should not be made public until it has been fully
  # configured and tested in production.
  isPublic: Boolean = false
  # Human-readable name for the engine
  name: String!
  # An optional description for the engine.
  description: String
  # The engine category
  categoryId: String!
  # The engine deployment model. See the DeploymentModel enum for options.
  deploymentModel: DeploymentModel!
  # An optional price indicator for the engine.
  price: Int
  # Optionally, supply custom fields that the user can set when launching
  # the engine. See developer documentation for details.
  fields: [CreateEngineField!]
  # The path for an icon image
  iconPath: String
  # The path for a logo image
  logoPath: String
  # Optionally, supply dependency information about this engine.
  # Currently this field cannot be set through the API
  # dependency: CreateEngineDependency

  # Whether or not the engine requires a library.
  libraryRequired: Boolean = false

  # Whether or not the engine creates a TDO
  createsTDO: Boolean = false
}

# Enumeration containing the set of allowed values for the Engine state field.
enum EngineState {
  # The engine is deployed and active. Set the state to this value to deploy it.
  active
  # The engine has been disabled. Set this state to disable the engine.
  disabled
  # The engine is awaiting approval before transitioning to the next state.
  pending
  # The engine has been deleted and is no longer available for use.
  deleted
  # The engine is in draft state, suitable for review and internal testing.
  draft
  # The engine is ready for deployment, but has not been deployed yet.
  ready
}

# Input fields used to update an existing engine.
input UpdateEngine {
  # Supply the ID of the engine to update
  id: ID!
  # Indicates whether or not the engine should be public -- visible to and
  # usable by users outside the creator's organization.
  # Typically an engine should not be made public until it has been fully
  # configured and tested in production.
  isPublic: Boolean
  # Human-readable name for the engine. Changing this value will change
  # how the engine appears to users.
  name: String
  description: String
  categoryId: String
  # The engine deployment model. See the DeploymentModel enum for options.
  deploymentModel: DeploymentModel
  # An optional price indicator for the engine.
  price: Int

  # Optionally, supply custom fields that the user can set when launching
  # the engine. See developer documentation for details. To update the fields,
  # make sure you supply the complete set of new fields -- new fields,
  # updated existing fields, and unmodified existing fields.
  fields: [CreateEngineField!]
  # The path for an icon image
  iconPath: String
  # The path for a logo image
  logoPath: String

  # Optionally, supply dependency information about this engine.
  # Currently this field cannot be set through the API
  # dependency: UpdateEngineDependency

  # Whether or not the engine requires a library.
  libraryRequired: Boolean
}

input EngineWorkflow {
  id: ID!
  action: EngineWorkflowAction!
}

enum EngineWorkflowAction {
  enable
  disable
}

# An enum containing valid custom engine field types.
enum EngineFieldType {
  # A number, in float format
  Number
  # A pick list that allows the user to choose one of a set of allowed values.
  Picklist
  # A pick list that allows the user to choose any number of a set of allowed values.
  MultiPicklist
  # A plain text field
  Text
  # A dynamic list of schemas that will be populated by the client
  SchemaSelection
}

# Represents a custom input field on an engine.
type EngineField {
  # Maximum value, in float format. Applies only to fields of type Number.
  max: Float
  # Minimum value, in float format. Applies only to fields of type Number.
  min: Float
  # Numerical step by which the value should be incremented or decremented in
  # the user interface, in float format. Applies only to fields of type Number.
  step: Float
  # The field type.
  type: EngineFieldType!
  # General information about the field, such as a description.
  info: String
  # A machine-readable name, or key, for the field.
  name: String!
  # A human-readable label for the field.
  label: String
  # A set of allowed values for the field. Applies only to fields of type
  # picklist or multi-picklist.
  options: [EngineFieldPicklistOption!]
  # An optional default value for the field. Taken in string format, but
  # applies to all field types.
  defaultValue: String
  # Optional default values to apply to a picklist. This field
  # should only be set for a field of type multi-picklist.
  defaultValues: [String!]
}

input CreateEngineField {
  # Maximum value, in float format. Applies only to fields of type Number.
  max: Float
  # Minimum value, in float format. Applies only to fields of type Number.
  min: Float
  # Numerical step by which the value should be incremented or decremented in
  # the user interface, in float format. Applies only to fields of type Number.
  step: Float
  # The field type.
  type: EngineFieldType!
  # General information about the field, such as a description.
  info: String
  # A machine-readable name, or key, for the field.
  name: String!
  # A human-readable label for the field.
  label: String!
  # A set of allowed values for the field. Applies only to fields of type
  # picklist or multi-picklist.
  options: [CreateEngineFieldPicklistOption!]
  # An optional default value for the field. Taken in string format, but
  # applies to all field types.
  defaultValue: String
  # Optional default values to apply to a picklist. This field
  # should only be set for a field of type multi-picklist.
  defaultValues: [String!]
}

# Represents one allowed option in a picklist.
type EngineFieldPicklistOption {
  # The human-readable label for the option, such as "English-US" for a language selector.
  key: String!
  # The machine-readable value that will be sent in the engine payload, such as
  # "en-us" for a language selector.
  value: String!
}

# Represents one allowed option in a picklist.
input CreateEngineFieldPicklistOption {
  # The human-readable label for the option, such as "English-US" for a language selector.
  key: String!
  # The machine-readable value that will be sent in the engine payload, such as
  # "en-us" for a language selector.
  value: String!
}

# Represents single chunk of engine results for date range
type EngineResult {
  tdoId: ID!
  engineId: ID!
  jsondata: JSONData
  startOffsetMs: Int
  stopOffsetMs: Int
  assetId: String
  userEdited: Boolean
  tdo: TemporalDataObject
}

# Represents a collection of engine results. Not Paged.
type EngineResultList {
  sourceId: ID
  records: [EngineResult]
}

# Represents a single engine task
type Task {
  # The task ID
  id: ID!
  name: String
  description: String
  # Date and time the task was created
  createdDateTime: DateTime
  # Date and time the task was last modified
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  # Date and time the task was queued for execution.
  queuedDateTime: DateTime
  # Date and time the task completed.
  completedDateTime: DateTime
  # Date and time task execution started
  startedDateTime: DateTime
  # The task status. See TaskStatus enum for details.
  status: TaskStatus
  # Optional order in which the task should run, relative to other tasks
  # in the job that contains it.
  order: Int
  # Whether or not the task is run on the clone of a TDO
  isClone: Boolean
  # Application ID that owns the task
  applicationId: String
  # The ID of the TemporalDataObject the task
  # was created for.
  targetId: ID
  # The TemporalDataObject the task was created for.
  target: TemporalDataObject
  # ID of the engine for the task.
  engineId: ID
  # The engine for the task
  engine: Engine
  # The ID of the job that contains this task
  jobId: ID
  # The job that contains this task.
  job: Job
  # ID of the engine build used for this task.
  buildId: ID
  # The engine build used for this task
  build: Build
  # The source asset for this task, if there is one.
  sourceAsset: Asset
  # The ID of the source asset for this task, if there is one.
  sourceAssetId: ID
  mediaLengthSec: Int
  mediaStorageBytes: Int
  mediaFileName: String
  # The incoming task payload, in JSON format
  payload: JSONData
  # The task output, in JSON format.
  output: JSONData
  # The incoming task payload, in String format.
  payloadString: String
  # The task output, in String format.
  outputString: String
  # The log file produced during task execution
  log: TaskLog
  # For backwards compatibility only
  taskPayload: JSONData
  # For backwards compatibility only
  taskOutput: JSONData
  # True if this task was created as a test task
  testTask: Boolean

  parentTaskId: ID
  parentTask: Task

  childTaskIds: [ID!]
  childTasks: [Task!]

  # A standby task that will execute if this one fails.
  standbyTask: Task
  # The task that this task is a standby for. If the task
  # identified in this field fails, the current task will execute.
  standbyForTask: Task

  # Contains metadata used by the platform run-time system to execute
  # the task. This field is accessible only to platform components.
  runtimePayload: JSONData
    # @scopes(
      scopes: ["task_type.internal", "master", "superadmin"]
      require: Any
    )
}

type TaskLog {
  # URI to the task log file
  uri: String
  # The entire text contents of the log file. Note that this value can long.
  text: String
  # The log file in JSON form. If the log file contains valid JSON,
  # this field will contain the native structure. If the log file does not
  # contain valid JSON, this field will contain a single property called
  # `text` with a string value containing the entire log file.
  jsondata: JSONData
}

enum JobStatus {
  pending
  complete
  running
  cancelled
  queued
}

enum JobStatusFilter {
  pending
  running
  complete
  cancelled
  queued
}

enum TaskStatus {
  pending
  running
  complete
  queued
  accepted
  failed
  cancelled
  standby_pending
  waiting
  resuming
  aborted
}

type TaskList implements Page {
  records: [Task]
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
}

enum UpdateTaskStatus {
  running
  failed
  complete
  waiting
}

input UpdateTask {
  id: ID!
  status: TaskStatus!
  jobId: ID
  output: JSONData
  # Task output as JSON string
  outputString: String
  # Use this parameter if your task output does not take the form of valid
  # JSON. Provide a key and the server will convert your output into
  # JSON with a single string value. For example,
  # ```
  #   mutation {
  #     updateTask(input: {
  #       id: <id>
  #       outputString: "<xml><stuff id=\"value\">more stuff </stuff></xml>"
  #       outputJsonKey: "response"
  #     }) { id }
  #   }
  #
  # ```
  # Will set the task output JSON to
  #  ` {"response":"<xml><stuff id=\"value\">more stuff </stuff></xml>"}`
  outputJsonKey: String
  # Backwards compatibility only
  taskOutput: JSONData
  # Update the task with a new payload
  payload: JSONData
  # Save execution location metadata
  executionLocationData: JSONData
}

input PollTask {
  id: ID!
  jobId: ID!
  pollPayload: JSONData
}

type EngineCategory {
  id: ID!
  name: String
  description: String
  type: EngineType
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  # The list of IDs of engines in this category
  engineIds: [ID!]
  totalEngines: Int
  iconClass: String
  editable: Boolean
  videoOnly: Boolean
  color: String
  # The list of engines in this category
  engines(
    offset: Int = 0
    limit: Int = 30
    # Filters for engine attributes
    filter: EngineFilter
    # Provide a list of EngineSortField to sort by.
    orderBy: [EngineSortField]
  ): EngineList
    # @scopes(
      scopes: [
        "developer.engine.read"
        "cms.workflows.create"
        "cms.job.create"
        "job.create"
      ]
      require: Any
    )
  # If the engine category is integrated with libraries, this field contains
  # the list of IDs of entity identifier types that the engine category is compatible
  # with.
  libraryEntityIdentifierTypeIds: [ID!]
  # If the engine category is integrated with libraries, this field contains
  # the list of entity identifier types that the engine category is compatible
  # with.
  libraryEntityIdentifierTypes: EntityIdentifierTypeList

  # A type for the engine category. Multiple engine categories with common
  # elements can share a categoryType. This information is used to compute
  # dependencies and format user interface elements.
  categoryType: String

  # An optional key used to identify this engine category's results for
  # search and other purposes.
  # Primarily used by Veritone platform applications.
  categoryMetadataKey: String

  # A list of categoryTypes on which instances of this engine category depend.
  dependencies: [EngineDependency!]

  # Information about how engine results in this category can be searched
  # in Veritone platform applications.
  # Used primarily by Veritone platform applications.
  searchConfiguration: EngineSearchConfiguration

  # List of engine result export formats supported by engines in this
  # category. May be empty.
  exportFormats: [ExportFormat]!
}

type ExportFormat {
  # The file format/extension i.e. ttml, vlf, etc.
  format: String!
  # A human readable label for the file format i.e. "Time Text Markup Language"
  label: String!
  # A list types to categories the file format by i.e. "subtitle"
  types: [String]!
}

# Represents configuration on how the results of engines within a given
# category are indexed and searched.
# Primarily used by Veritone platform applications.
type EngineSearchConfiguration {
  # Autocomplete field information is used to tell client applications
  # what fields are searchable by autocomplete in the search index and
  # how to search for them.
  autocompleteFields: [AutocompleteFieldConfig!]
  # Autocomplete field information is used to tell client applications
  # what fields are searchable in the search index and
  # how to search for them.
  searchFields: [SearchFieldConfig!]
  # Indicates whether or not search is available for results produced
  # by engines in this category can be searched.
  isSearchEnabled: Boolean
  # Indicates whether or not search is available for results produced
  # by engines in this category can be searched within the Elasticsearch index.
  isElasticEnabled: Boolean
  searchMetadataKey: String
  elasticType: String
}

type SearchFieldConfig {
  searchField: String
  indexField: String
}

type AutocompleteFieldConfig {
  autocompleteField: String
  indexField: String
}

type EngineCategoryList implements Page {
  records: [EngineCategory!]
  offset: Int!
  limit: Int!
  count: Int
}

type EngineType {
  name: String
  description: String
}

type EngineBlacklist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

type EngineWhitelist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

input EngineFilter {
  # Language supported by the engine
  language: String
  # provide a list of engine category names to filter by
  category: [String]
  # provide a list of engine type names to filter by
  type: [EngineTypeFilter!]
  # Provide a list of rating from 0 to 5 to filter by.
  rating: [Int]
  # Specify the deployment model of the engine.
  deploymentModel: DeploymentModel
  # Specify the minimum price of the engine.
  priceMin: Int
  # Specify the maximum price of the engine.
  priceMax: Int
  # Specify the minimum FedRamp impact level of the engine.
  fedRampImpactLevelMin: Int
  # Specify the minimum FedRamp impact level of the engine.
  fedRampImpactLevelMax: Int
  # Filter engines that can be trainable via API.
  trainableViaApi: Boolean
  # Filter engines by cluster size.
  clusterSize: ClusterSize
  # Filter engines by gpu supported.
  gpuSupported: SupportedGPU
  # Provide a list of engine modes to filter by
  mode: [EngineMode!]
  # Provide a list of runtime types to filter by
  runtimeType: [String!]
}

enum EngineTypeFilter {
  Cognition
  Ingestion
  Aggregator
}

input EngineSortField {
  field: EngineOrderField!
  direction: OrderDirection
}

enum EngineOrderField {
  name
  id
  state
  price
  rating
  order
  createdDateTime
  modifiedDateTime
}

enum ClusterSize {
  small
  medium
  large
}

enum SupportedGPU {
  G2
  G3
  P2
}

type Build {
  id: ID!
  name: String
  description: String
  # Date and date build was created
  createdDateTime: DateTime
  # Date and time build was last modified
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  # The ID of the engine this build is for
  engineId: ID!
  # The engine this build is for
  engine: Engine
  price: Int
  validateUri: String
  executeUri: String

  # Engine build status:
  status: BuildStatus
  # URL to the Docker image for this engine build, if applicable
  dockerImage: String
  runtime: JSONData
  version: String
  #
  report: JSONData
  # The entire manifest, supplied by the engine developer, that describes
  # the engine's capabilities and requirements and is used by the platform
  # system to build and execute the engine.
  manifest: JSONData
  preferredInputFormat: String
  supportedInputFormats: [String!]
  outputFormats: [String!]
  # List of IDs of source types that the engine supports.
  # Applies only to adapter engines that ingest data from a source.
  # Will be a list of IDs of SourceType objects.
  supportedSourceTypes: [String!]
  # Used to give a default action choice
  primaryAction: BuildUpdateAction
  # Used to give secondary action choices
  secondaryActions: [BuildUpdateAction]
  # Contains all valid action choices
  validStateActions: [BuildUpdateAction]
}

# Valid strings for the `Build.status` field.
enum BuildStatus {
  # The build has been approved and is ready for deployment
  approved
  # The build is available for deployment
  available
  # The build has been soft-deleted.
  deleted
  # The build is being deployed.
  deploying
  # The build has been deployed. There can be only one deployed build.
  deployed
  # The build files are being fetched from their source.
  fetching
  # The build failed validation checks. See build report for details.
  invalid
  # The build is deployed but has been paused. Engine processing will not
  # proceed until the build is un-paused.
  paused
  # The build has been created but is still pending approval and other
  # workflow steps.
  pending
  # The build has been successfully uploaded to the build repository.
  uploaded
  # Deployment has failed
  deployFailed
}

enum BuildUpdateAction {
  deploy
  pause
  unpause
  approve
  disapprove
  invalidate
  submit
  upload
  delete
  #    restart
}

input UpdateBuild {
  id: ID!
  engineId: ID!
  action: BuildUpdateAction!
  dockerImage: String
}

input CreateBuild {
  engineId: ID!
}

input DeleteBuild {
  id: ID!
  engineId: ID!
}

type BuildList implements Page {
  records: [Build]
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type Job {
  # ID of the job
  id: ID!
  # User-provided job name
  name: String
  # Optional job description
  description: String
  #
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  # ID of the target object for the job, such as a container or Recording
  targetId: ID
  # Source asset ID
  sourceAssetId: ID
  # Overall job status, as computed from the statuses of its component tasks
  status: TaskStatus
  # Tasks the job has or will execute
  tasks(
    # Specify a list of job status strings to filter by status
    status: [TaskStatus!]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Maximum number of results to retrieve in this query
    limit: Int = 30
    # Specify an ID to retrieve a single specific task
    id: ID
    # Specify a list of IDs to filter by task target ID
    targetId: [ID]
    hasSourceAsset: Boolean
  ): TaskList
  # Application the job ran under
  applicationId: ID
  # Target TemporalDataObject
  target: TemporalDataObject
  # ID of the cluster where this job will be executed
  clusterId: ID
}

input JobSortField {
  field: JobOrderField!
  direction: OrderDirection = desc
}

enum JobOrderField {
  createdDateTime
  modifiedDateTime
}

type JobList implements Page {
  # Jobs retrieved
  records: [Job]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

input CreateJob {
  status: String
  targetId: ID
  tasks: [CreateTask!]
  retries: Int = 0
  # Supply a scheduled job ID to indicate that this
  # job was created based on the given scheduled job.
  # To create a job _from_ a scheduled job, use `launchScheduledJobs`
  scheduledJobId: ID
  # Supply a job template ID to indicate that this
  # job was created from the given job template.
  # To create a job _from_ a template, use `launchJobTemplates`.
  jobTemplateId: ID
  skipDecider: Boolean
  # Optionally, specify a cluster ID where the job should run.
  # Both the organization and the engine must have access to the cluster.
  clusterId: ID
  # Optional job config information. Typically used only by Veritone
  # platform components.
  jobConfig: JSONData
  # Optionally, specify the scheduled job ID that this job is associated
  # with. Typically it is not necessary for a client to set this; it is
  # handled internally by the API.
  scheduledJobId: ID
}

# Fields required to create a task. Used when creating a job.
input CreateTask {
  # The task type, which is mapped on the server to an engine ID.
  # Either taskType OR engineId is required.
  taskType: String
  # Engine ID to be used for the task.
  # Either engineId OR taskType is required.
  engineId: ID
  # Task payload in raw string form.
  # Optional. Only one of payloadString and payload is permitted.
  payloadString: String
  # Task payload in GraphQL format.
  # Optional. Only one of payloadString and payload is permitted.
  payload: JSONData
  # Optional. Specifies whether or not the task target should be cloned.
  isClone: Boolean
  # Optional. Specifies the build ID of the engine
  buildId: String
  # Optional. Specifies whether the task is for testing.
  testTask: Boolean

  # Optionally, provide a task definition that will be executed if
  # and only if this one fails. Standby tasks can be nested.
  standbyTask: CreateTask
}

######## admin API

# An application is a set of Veritone functionality that customers can sign up for.
type Application {
  id: ID!
  key: String!
  name: String!
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  deploymentModel: DeploymentModel
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  # OAuth2 client secret. This field is server-generated and is only
  # returned on application creation.
  clientSecret(password: String): String
  # OAuth2 redirect URLs
  oauth2RedirectUrls: [String]
  organizationId: ID!
  status: ApplicationStatus
  permissionsRequired: [String]
  contextMenuExtensions: ContextMenuExtensionList
  validStateActions: [ApplicationStateAction]
}

enum ApplicationStateAction {
  approve
  edit
  delete
  deploy
  disable
  enable
  reject
  submit
  undelete
}

type ApplicationList implements Page {
  records: [Application]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type ContextMenuExtensionList {
  mentions: [ContextMenuExtension]
  tdos: [ContextMenuExtension]
  watchlists: [ContextMenuExtension]
  collections: [ContextMenuExtension]
}

type ContextMenuExtension {
  id: ID!
  label: String!
  url: String!
}

input CreateContextMenuExtensions {
  mentions: [CreateContextMenuExtension] = []
  tdos: [CreateContextMenuExtension] = []
  watchlists: [CreateContextMenuExtension] = []
  collections: [CreateContextMenuExtension] = []
}

input UpdateContextMenuExtensions {
  mentions: [UpdateContextMenuExtension] = []
  tdos: [UpdateContextMenuExtension] = []
  watchlists: [UpdateContextMenuExtension] = []
  collections: [UpdateContextMenuExtension] = []
}

input CreateContextMenuExtension {
  label: String!
  url: String!
}

input UpdateContextMenuExtension {
  id: ID
  label: String!
  url: String!
}

input BulkDeleteContextMenuExtensions {
  # List of IDs of context menu extensions to delete
  ids: [ID!]
}

type Permission {
  id: ID!
  name: String
  description: String
}

type PermissionList implements Page {
  records: [Permission]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

# A user represents a user account within an organization.
type User {
  # The user's name
  name: String!
  # The user's unique ID.
  # A user ID is a string in UUID format.
  id: ID!
  # The set of permissions granted to the user
  permissions: PermissionList
  # The set of roles granted to the user
  roles: [Role!]
  roleIds: [ID!]

  # ID of the organization to which the user belongs.
  organizationId: ID
  # Organization to which the user belongs.
  organization: Organization
  # Freeform metadata in JSON form
  jsondata: JSONData
  firstName: String
  lastName: String
  email: String
  acls: [UserACL!]
  # Folder tree for this organization
  rootFolder(
    # Specify a root folder type to retrieve a specific root folder
    type: RootFolderType = watchlist
  ): Folder
  # Date and time this user last changed their password
  passwordUpdatedDateTime: DateTime
  # Date and time this user last logged in
  lastLoginDateTime: DateTime
  # Date and time this user account was created
  createdDateTime: DateTime
  # Date and time this user account was last modified
  modifiedDateTime: DateTime

  # Multi-factor authentication information for the user
  mfaInfo: MFAInfo!

  # User Settings for the user
  userSettings: [UserSetting!]
  imageUrl: String

  # Status of user account
  status: UserStatus
}

enum UserStatus {
  active
  suspended
  deleted
}

# Type that holds user setting for a user
type UserSetting {
  key: String
  value: String
}

# Type that holds multi-factor authentication for a user
type MFAInfo {
  phoneNumber: String
  smsVoiceVerifiedDateTime: DateTime
  gaVerifiedDateTime: DateTime
  defaultOption: String
  pendingRegistration: String
}

type UserACL {
  applicationId: ID
  organizationId: ID
  organization: Organization
  objectType: String
  objectId: String
  access: UserACLAccessRights
  userId: ID
}

type UserACLAccessRights {
  owner: Boolean
}

type PasswordTokenInfo {
  passwordToken: String
}

input CreateOrganization {
  name: String!
  applications: JSONData
  # Metadata in JSON format.
  metadata: JSONData!
  adminSeatLimit: Int # @scopes(scopes: ["veritone.financeadmin"])
  seatLimit: Int # @scopes(scopes: ["veritone.financeadmin"])
  status: OrganizationStatus = active
  maxAiwareNodes: Int
  maxAiwareClusters: Int
  businessUnit: String!
  integrations: JSONData
  types: [OrganizationType]
}

enum OrganizationType {
  agency
  broadcaster
}

input CreateUser {
  name: String!
  # Metadata in JSON format. If a field is provided elsewhere in the
  # payload, it does not need to be saved in jsondata.
  jsondata: JSONData
  # User who requested that the new user be provisioned
  requestorId: ID
  # Password for new user. Optional - if not provided, the user will
  # need to set on first login.
  password: String
  organizationId: ID!
  sendNewUserEmail: Boolean
  email: String
  roleIds: [ID!]
  acls: [UserACLInput!]

  # Optionally, specify user's first name
  firstName: String
  # Optionally, specify user's last name
  lastName: String
}

input UserACLAccessRightsInput {
  owner: Boolean
}

input UserACLInput {
  applicationId: ID
  organizationId: ID
  objectType: String
  objectId: String
  access: UserACLAccessRightsInput
  userId: ID
}

input UpdateUser {
  id: ID!
  name: String
  jsondata: JSONData
  roleIds: [ID!]
  acls: [UserACLInput!]
  # Optionally, specify user's first name
  firstName: String
  # Optionally, specify user's last name
  lastName: String
}

input CreatePasswordUpdateRequest {
  # The user's ID
  id: ID!
  # Optionally specify whether we should skip sending the reset email.
  skipPasswordResetEmail: Boolean
}

input CreatePasswordResetRequest {
  # Optionally specify whether we should skip sending the reset email.
  skipPasswordResetEmail: Boolean
  # The user login name. Typically email address.
  userName: String!
}

input UpdateCurrentUser {
  # Required if updating the MFA phone number
  passwordToken: String
  # New MFA info for the current user, optional
  mfaInfo: UpdateMFAInfo
  # New user settings for the current user, optional
  userSetting: UserSettingInfo
  # New first name for the current user, optional
  firstName: String
  # New last name for the current user, optional
  lastName: String
  # New image URL for the current user, optional
  imageUrl: String
}

input UserSettingInfo {
  key: String
  value: String
}

input UpdateMFAInfo {
  phoneNumber: String
}

input GetCurrentUserPasswordToken {
  password: String
}

# Fields used to update an organization.
input UpdateOrganization {
  # ID of the organization to update
  id: ID!
  # Name of the organization
  name: String
  type: String
  seatLimit: Int
  status: String
  applications: [ID!]
  businessUnit: String

  # Currently only Veritone administrators can modify this field.
  metadata: JSONData

  # Update the engine blacklist for this organization.
  # Currently only Veritone administrators can modify this field.
  # Updating this field will completely replacing the existing engine
  # and engine category blacklists with the IDs provided.
  blacklist: SetEngineBlacklist # @scopes(scopes: ["superadmin"])
  # Update the engine whitelist for this organization.
  # Currently only Veritone administrators can modify this field.
  # Updating this field will completely replacing the existing engine
  # and whitelist with the IDs provided.
  whitelist: SetEngineWhitelist # @scopes(scopes: ["superadmin"])
}

input SetEngineBlacklist {
  # Provide the organization ID to update. This field is required only
  # when using addToEngineBlacklist or deleteFromEngineBlacklist.
  organizationId: ID
  # Provide the IDs of engines to set.
  engineIds: [ID!]
  # Provide the IDs of engine categories to set.
  engineCategoryIds: [ID!]
}

input SetEngineWhitelist {
  # Provide the organization ID to update. This field is required only
  # when using addToEngineWhitelist or deleteFromEngineWhitelist.
  organizationId: ID
  engineIds: [ID!]
}

type UserList implements Page {
  records: [User]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

# A role signifies a user's permissions within a given context.
type Role {
  description: String
  appName: String
  name: String!
  permissions: PermissionList
  id: ID!
}

type Group {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  applicationId: ID!
  createdBy: User
  modifiedBy: User
  organizationId: ID!
  organization: Organization
  # Freeform metadata in JSON form
  jsondata: JSONData
}

type GroupList implements Page {
  records: [Group]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

enum OrganizationStatus {
  active
  deleted
}

type Organization {
  # The organization ID
  id: ID!
  # The organization's name
  name: String
  # A list of types applied to the organization, such
  # as `Broadcaster` or `Agency`.
  type: [String]
  # Applications belonging to the organization
  applications(offset: Int = 0, limit: Int = 30): ApplicationList
  # Freeform metadata in JSON format
  jsondata: JSONData
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  seatLimit: Int
  # Organization's current status
  status: OrganizationStatus
  # Roles allowed within the organization
  roles: [Role]
  # Users belonging to the organization
  users(offset: Int = 0, limit: Int = 30): UserList
  # List of engines forbidden to this organization.
  blacklist: EngineBlacklist # @scopes(scopes: ["superadmin"])
  # List of engines allowed for this organization.
  # Takes precedence of the blacklist. That is, if a whitelist
  # is defined, then only engines in the whitelist are permitted
  # regardless of what is in the blacklist.
  # This field is not fully implemented!
  whitelist: EngineWhitelist
  # Custom schemas defined by this organization.
  # This field is not fully implemented!
  schemas: SchemaList
  # Watchlists for this organization.
  # This field is not fully implemented!
  watchlists: WatchlistList
  # Collections for this organization
  collections(
    # Provide a name to filter by collection name
    name: String
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): CollectionList
  # Folder tree for this organization
  rootFolder(
    # Specify a root folder type to retrieve a specific root folder
    type: RootFolderType = watchlist
  ): Folder
  # Business unit
  businessUnit: String
  # Dashboards
  dashboards: [Dashboard]
  imageUrl: String

  # An ID corresponding to the organization used internally for some
  # provisioning elements. `applicationId` on `TemporalDataObject`, `Job`,
  # and some other types uses this value instead of the organization `id`.
  internalApplicationId: ID
  # The number of active seats
  seats: Int
}

# Analytics Dashboards
type Dashboard {
  # The order in which to display the dashboard.
  index: Int
  title: String
  description: String
  # The status of the dashboard
  active: Boolean
  # The filters that can be applied on the dashboard. Typically watchlists.
  filters: [String]
  type: String
  # Vendor specific identifier for Qlik applications
  qlikAppId: String
  # Vendor specific identifier for Qlik sheet
  qlikSheetId: String
  thumbnail: String
}

type OrganizationList implements Page {
  records: [Organization]
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

#### Mentions and search

input SearchInput {
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int = 0
  # Maximum number of results that were retrieved in this query; page size
  limit: Int = 0
  index: [String]!
  query: JSONData!
  select: JSONData
}

type MentionList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [Mention!]
}

input MentionDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: MentionDateTimeField!
}

enum MentionDateTimeField {
  mentionDate
  endDateTime
  hitStartDateTime
  hitStopDateTime
}

enum MentionOrderByField {
  id
  mentionDate
  hitStartDateTime
  hitEndDateTime
  endDateTime
}

input MentionOrderBy {
  field: MentionOrderByField!
  direction: OrderDirection = desc
}

type Mention {
  id: ID!
  organizationId: ID!
  sourceTypeId: ID
  sourceId: ID
  scheduleId: ID
  mediaId: ID
  advertiserId: ID
  brandId: ID
  campaignId: ID
  watchlistId: ID
  statusId: ID
  complianceStatusId: ID
  spotTypeId: ID
  audienceMarketCount: Int
  audienceAffiliateCount: Int
  mentionHitCount: Int
  audience: Int
  mentionRating: Int
  isMatch: Boolean
  mentionDate: DateTime
  metadata: JSONData
  mentionSnippets: [MentionSnippets]
  userSnippets: [MentionUserSnippets]
  adCreative: JSONData
  fingerprint: JSONData
  cognitiveEngineResults: JSONData
  comments: MentionCommentList
  hash: ID
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  endDateTime: DateTime
  scheduledJob: ScheduledJob
  temporalDataObject: TemporalDataObject
  organization: Organization!
  watchlist: Watchlist
  advertiser: JSONData
  brand: JSONData
  queryTerm: String
  ratings(userId: ID): MentionRatingList
}

type MentionUserSnippets {
  text: String
  startTime: Float
  endTime: Float
  transcriptStartDate: String
  transcriptEndDate: String
}

type MentionSnippets {
  text: String
  startTime: Float
  endTime: Float
  hits: [MentionHit]
}

type MentionHit {
  queryTerm: String
  startTime: Float
  endTime: Float
}

input CreateMention {
  mediaId: ID!
  programId: ID!
  mentionDateTime: DateTime!
  mentionHitCount: Int!
  mentionStatusId: Int
  watchlistId: ID
  cognitiveEngineResultsString: String
  snippetsString: String
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  mentionEndDateTime: DateTime
  metadata: JSONData
  queryTerm: String
}

input CreateMentionComment {
  mentionId: ID!
  commentText: String!
}

input UpdateMentionComment {
  mentionId: ID!
  commentId: ID!
  commentText: String!
}

input DeleteMentionComment {
  mentionId: ID!
  commentId: ID!
}

input CreateMentionRating {
  mentionId: ID!
  ratingValue: Int!
}

input UpdateMentionRating {
  mentionId: ID!
  ratingId: ID!
  ratingValue: Int!
}

# Input required to delete a mention rating.
# Both the rating and mention IDs must be provided.
# Only the rating will be deleted.
input DeleteMentionRating {
  # The mention ID
  mentionId: ID!
  # The rating ID
  ratingId: ID!
}

type MentionComment {
  commentId: ID!
  mentionId: ID
  userId: ID
  firstName: String
  lastName: String
  userImage: String
  commentText: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionRating {
  ratingId: ID!
  mentionId: ID
  userId: ID
  ratingValue: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionRatingList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionRating]
}

type MentionCommentList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionComment]
}

### Collections and folders

enum RootFolderType {
  watchlist
  collection
  cms
}

enum FolderStatus {
  active
  inactive
}

type Folder {
  # The ID of this folder
  id: ID!
  treeObjectId: ID!
  # The name of this folder
  name: String
  # An optional description
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  ownerId: String
  # The parent folder
  parent: Folder
  # The subfolders of this folder
  subfolders: [Folder!]
  # The organization that owns this folder
  organization: Organization
  # The ID of the organization that owns this folder
  organizationId: ID
  typeId: Int
  rootFolderTypeId: Int
  # The maximum depth of child folders allowed
  maxDepth: Int
  orderIndex: Int
  # The folder status
  status: FolderStatus
  # The ordered path of the folder hierarchy. The first element
  # is always a root folder, and the last is this folder's parent.
  folderPath: [Folder!]
  # TemporalDataObjects that are filed in this folder
  childTDOs(offset: Int = 0, limit: Int = 30): TDOList
  # The read/write permissions for a shared folder
  sharedAccess: [String]
  sharedWith: SharedWith
  contentTemplates: [FolderContentTemplate!]!
}

type FolderContentTemplate {
  id: ID!
  folderId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSONData
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type SharedWith {
  # List of organizationIds that have read access to this object
  read: [Int]
  # List of organizationIds that have write access to this object
  write: [Int]
}

type Share {
  id: ID!
  recipients: [String]
  shareMessage: String
  shareOptionsJson: JSONData
  folderId: ID
  mentionId: ID
}

type Collection {
  id: ID!
  name: String!
  # A url to get the collection image
  imageUrl: String
  # A sigend url to get the collection image. It will only be signed if it is an s3 url.
  signedImageUrl: String
  ownerId: ID
  description: String
  organization: Organization
  organizationId: ID!
  orgSharing: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  programCount: Int
  itemCount: Int
  typeId: ID
  isActive: Boolean
  widgets(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Maximum number of results to retrieve in this query; page size
    limit: Int = 30
    id: ID
  ): WidgetList
}

input CreateCollection {
  # the name of the collection
  name: String!
  # description of the collection
  folderDescription: String
  # Collection image
  image: String
}

input UpdateCollection {
  # id of the collection
  folderId: ID!
  # the name of the collection
  name: String
  # description of the collection
  folderDescription: String
  # Collection image
  image: String
}

input ShareCollection {
  # id of the collection
  folderId: ID!
  # message in email
  shareMessage: String
  # list of recipients
  recipients: [String]
  # Collection image
  shareOptions: ShareOptions
}

input ShareMentionFromCollection {
  # id of the mention from collection
  mentionId: ID!
  # id of the collection
  folderId: ID!
  # message in email
  shareMessage: String
  # list of recipients
  recipients: [String]
  # Collection image
  shareOptions: ShareOptions
}

input CollectionMentionInput {
  # id of the collection
  folderId: ID!
  # id of the mention
  mentionId: ID!
}

type CollectionMention {
  # id of the collection
  folderId: ID!
  # id of the mention
  mentionId: ID!
}

input ShareOptions {
  showImage: Boolean
  showComments: Boolean
  showRating: Boolean
  showHeader: Boolean
  showOrganizationLogo: Boolean
  organizationLogoUrl: Boolean
  showEngineResults: Boolean
  showHits: Boolean
  showAffiliateStripdown: Boolean
  showDownload: Boolean
  showDescription: Boolean
}

type CollectionList implements Page {
  records: [Collection]
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type Watchlist {
  # The primary ID
  id: ID!
  # A human-readable name for the watchlist
  name: String!
  # The organization that owns the watchlist
  organization: Organization!
  # ID of the organization that owns the watchlist
  organizationId: ID!

  # IDs of the schedules associated with the watchlist
  scheduleIds: [ID!]

  # Date and time at which the watchlist takes effect
  startDateTime: DateTime
  # Date and time at which the watchlist is no longer in effect
  stopDateTime: DateTime
  # Date and time the watchlist was created
  createdDateTime: DateTime
  # Date and time the watchlist was last modified
  modifiedDateTime: DateTime

  # Cognitives searches associated with the watchlist
  cognitiveSearches: [CognitiveSearch!]

  # Ids of the source types associated directly with the watchlist
  sourceTypeIds: [ID!]

  # IDs of the sources associated directly with the watchlist
  sourceIds: [ID!]

  # Folders that the watchlist is filed in.
  # At present, a watchlist can only be filed in a single folder.
  folders: [Folder!]

  # Structured metadata associated with the watchlist.
  # Elements of the metadata are validated against specific schemas.
  details: JSONData

  subscriptions: [Subscription!]!

  searchIndex: SearchIndex!

  query: JSONData

  # Get mentions generated for this watchlist
  mentions(offset: Int = 0, limit: Int = 30): MentionList

  # ID of the advertiser directly with the watchlist
  advertiserId: ID

  # ID of the brand directly with the watchlist
  brandId: ID

  # advertiser associated with the watchlist
  advertiser: JSONData

  # brand associated with the watchlist
  brand: JSONData
}

enum SearchIndex {
  mine
  global
}

type WatchlistList implements Page {
  records: [Watchlist]
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

enum SubscriptionFrequency {
  immediate
  daily
  weekly
  never
}

enum SubscriptionObjectType {
  mention
}

enum DayOfWeek {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}

type Subscription {
  id: ID!
  organizationId: ID!
  objectType: SubscriptionObjectType!
  frequency: SubscriptionFrequency!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  isActive: Boolean!
  # The ID of the object on which this subscription is set,
  # such as a watchlist ID.
  targetId: ID!
  # Scheduled time of day
  scheduledTime: Time
  # Time zone of the scheduled time
  scheduledTimeZone: String

  # Scheduled day of the week
  scheduledDay: DayOfWeek

  jsondata: JSONData

  contact: SubscriptionContact!

  unsubscribeHash: String
}

type SubscriptionContact {
  userId: ID!
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

type CognitiveSearch {
  id: ID!
  # A recursive tree structure defining the search criteria
  profile: JSONData
  # ID of the mention status to set on each mention generated as a result
  # of a match against this search
  mentionStatusId: ID
  # The mention status to set on each mention generated as a result
  # of a match against this search
  mentionStatus: MentionStatus
  # The raw query. Read-only and server-generated based on the search profile.
  query: JSONData
}

input UpdateCognitiveSearch {
  id: ID!
  profile: JSONData
  jsonstring: String

  mentionStatusId: ID
}

type CognitiveSearchProfile {
  and: [CognitiveSearchProfile!]
  or: [CognitiveSearchProfile!]
  condition: CognitiveSearchCondition
  jsondata: JSONData
}

type CognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSONData!
}

type MentionStatus {
  id: ID!
  name: String!
}

input CreateCognitiveSearchInWatchlist {
  profile: JSONData
  # String with JSON containing the cognitive search profiles
  jsonstring: String

  mentionStatusId: ID!
}

input CreateCognitiveSearch {
  profile: JSONData
  jsonstring: String
  mentionStatusId: ID!
  watchlistId: ID!
}

input CreateCognitiveSearchProfile {
  and: [CreateCognitiveSearchProfile]
  or: [CreateCognitiveSearchProfile]
  condition: CreateCognitiveSearchCondition
}

input CreateCognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSONData!
}

input CreateWatchlist {
  # Date and time at which the watchlist becomes effective.
  # If not provided, defaults to current time.
  startDateTime: DateTime
  # Date and time at which the watchlist expires and is no longer effective.
  stopDateTime: DateTime!
  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]

  name: String!

  sourceTypeIds: [ID!] = [5] # temp default to 5 / private media
  # Optional ID for a folder the watchlist should be filed in
  parentFolderId: ID

  sourceIds: [ID!]

  # Set structured metadata on the watchlist.
  # The data is subject to a set of schemas.
  details: JSONData

  searchIndex: SearchIndex = global

  subscriptions: [CreateSubscriptionInWatchlist!]
}

input UpdateWatchlist {
  id: ID!
  startDateTime: DateTime
  stopDateTime: DateTime
  name: String
  sourceTypeIds: [ID!]
  # Set structured metadata on the watchlist.
  # The data is subject to a set of schemas.
  details: JSONData
  searchIndex: SearchIndex

  parentFolderId: ID

  sourceIds: [ID!]

  subscriptions: [CreateSubscriptionInWatchlist!]

  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]
}

input BulkUpdateWatchlist {
  # New stop date for watchlist. Currently, this is the only
  # field that can be updated.
  stopDate: DateTime
}

input BulkUpdateWatchlistFilter {
  # List of IDs of watchlists to update
  ids: [ID!]
}

type Widget {
  id: ID
  name: String
  organization: Organization
  organizationId: ID
  collection: Collection
  collectionId: ID!
  displayCollectionName: Boolean
  displayTranscription: Boolean
  width: Int
  numberOfMentionsToShow: Int
  adScript: String
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  createdDateTime: DateTime
}

type WidgetList implements Page {
  records: [Widget]
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

### Custom structured data

# An object containing custom structured data.
# This type is not fully implemented.
type StructuredJSONObject implements Metadata {
  data: JSONData
  schema: StructuredJSONSchema!
  name: String!
  id: ID!
}

# A custom structured data schema, specified in JSON.
# This type is not fully implemented.
type StructuredJSONSchema {
  schema: JSONData
  name: String!
  id: ID!
  ownerOrganizationId: ID!
  organization: Organization!
}

type JSONObject implements Metadata {
  name: String!
  data: JSONData
}

# Results from a mention or media search.
# TODO link to format documentation for core-search-server
type SearchResult {
  jsondata: JSONData!
}

type IngestionConfiguration {
  id: ID!
  applicationId: ID!
  type: String
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  emailAddress: String
  job: JSONData
  ui: JSONData
  jsondata: JSONData
}

input CreateIngestionConfiguration {
  applicationId: ID!
  type: String!
  name: String!
  # Container for arbitrary JSON-format metadata including configuration, etc.
  jsondata: JSONData
  # String containing raw JSON-format metadata. You can specify
  # either this value or jsondata, but not both.
  jsonstring: String
}

input UpdateIngestionConfiguration {
  id: ID!
  type: String
  name: String
  # Container for arbitrary JSON-format metadata including configuration, etc.
  jsondata: JSONData
  # String containing raw JSON-format metadata. You can specify
  # either this value or jsondata, but not both.
  jsonstring: String
}

type IngestionConfigurationList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [IngestionConfiguration]
}

# This type represents information about the Veritone GraphQL server
# instance. Primarily used by Veritone engineering and operations.
type GraphQLServiceInfo {
  # JSON structure containing build information, such as the build number and date.
  buildInfo: JSONData
  featureFlags: JSONData # @auth # @scopes(scopes: ["superadmin"])
  heartbeatStats: JSONData # @auth # @scopes(scopes: ["superadmin"], require: Any)
}

type DataRegistryList implements Page {
  records: [DataRegistry]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type DataRegistry {
  id: ID!
  name: String
  description: String
  source: String
  schemas(
    status: [SchemaStatus]
    majorVersion: Int
    id: ID
    offset: Int = 0
    limit: Int = 30
    orderBy: [SchemaOrder]
  ): SchemaList
  # The organization that owns this data registry.
  organization: Organization
  organizationId: ID
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  # The currently published schema version for convenient access.
  # This field will be empty if there is no published schema.
  publishedSchema: Schema
}

input SchemaOrder {
  field: SchemaOrderFields!
  direction: OrderDirection = desc
}

enum DataRegistryOrderBy {
  name
  source
  createdDateTime
  modifiedDateTime
}

enum SchemaOrderFields {
  majorVersion
  minorVersion
  status
  createdDateTime
  modifiedDateTime
}

type SchemaList implements Page {
  records: [Schema]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type Schema {
  id: ID!
  dataRegistryId: ID!
  dataRegistry: DataRegistry
  definition: JSONData
  majorVersion: Int!
  minorVersion: Int!
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: SchemaStatus
  # List of status the Schema can transition to.
  validActions: [SchemaAction]
  # SDOs under this schema
  structuredDataObjects(offset: Int = 0, limit: Int = 30): StructuredDataList
  # The organization that owns this schema.
  organization: Organization
  # The Id of the organization that owns this schema.
  organizationId: ID
}

enum SchemaStatus {
  published
  deleted
  draft
  inactive
}

enum SchemaAction {
  view
  edit
  publish
  deactivate
  delete
}

input CreateDataRegistry {
  # Optionally provide a forced ID
  id: ID
  name: String!
  description: String!
  source: String!
}

input UpdateDataRegistry {
  id: ID!
  name: String!
  description: String!
  source: String!
}

input UpsertSchemaDraft {
  dataRegistryId: ID!
  majorVersion: Int = 1
  schema: JSONData!
}

input UpdateSchemaState {
  # The schemaId to update
  id: ID!
  # The new schema status
  status: SchemaStatus!
  # Specify if publishing this schema would break ingestion
  breakingChanges: Boolean = false
}

type StructuredData {
  # The ID
  id: ID!
  # Id of the schema used to validate this object
  schemaId: ID!
  # The schema used to validate this object
  schema: Schema
  data(
    # Optionally, specify a path into the JSON data.
    # Only the value of the path will be returned, at the
    # top level. The value will be empty if there is nothing
    # in the JSON at that path.
    # This parameter is useful for directly addressing fields in the JSON.
    path: String
  ): JSONData
  dataString(indent: Int = 0): String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type StructuredDataList implements Page {
  records: [StructuredData]
  count: Int
  offset: Int!
  limit: Int!
}

input CreateStructuredData {
  # Optionally provide a forced ID
  id: ID
  # Id of the schema used to validate this object
  schemaId: ID!
  data: JSONData
  dataString: String
}

type SchemaPropertyList implements Page {
  records: [SchemaProperty]
  # The starting index for records that were returned in this query.
  offset: Int!
  # Maximum number of results that were retrieved in this query; page size
  limit: Int!
  # Number of records returned in this response
  count: Int
}

type SchemaProperty {
  dataRegistryId: ID!
  majorVersion: Int!
  schema: Schema!
  path: String!
  searchPath: String!
  type: String!
  title: String
}

input DataRegistryVersion {
  # The id of the DataRegistry
  id: ID!
  # The major version of the DataRegistry
  majorVersion: Int! = 1
}

# Contains information about a signed writable URL retrieved from the
# getSignedWritableUrl mutation.
type WritableUrlInfo {
  # The storage bucket ID
  bucket: String!
  # The storage object key
  key: String!
  # Time interval, in seconds, after which this URL is expired and no longer valid.
  expiresInSeconds: Int!
  # Absolute time at which this URL expires
  expiresAtDateTime: DateTime!
  # The signed URL, which can be uploaded to with an HTTP PUT (note:  PUT is
  # required. POST will generate an error).
  url: String!

  # A signed URL that can be used with HTTP GET to retrieve the
  # new resource.
  getUrl: String!

  # The unsigned, base URL to the object, which can be safely persisted
  # and re-signed later by a client with the necessary storage credentials.
  unsignedUrl: String
}

# The possible transformer functions which can be used with assets
enum TransformFunction {
  # Transform asset with XML format to JSON
  XML2JSON
  # Transfrom asset with XML Transcript format to JSON
  Transcript2JSON
  # Get asset JSON data as JSON
  JSON
}

# Used to control string matching on fields that support it
enum StringMatch {
  # Match if the target string field starts with the supplied value.
  # Case-insensitive.
  startsWith
  # Match if the target string field ends with the supplied value.
  # Case-insensive.
  endsWith
  # Match if the target string field contains the supplied value
  # anywhere in its content. Use only when strictly necessary, as
  # startsWith and endsWith offer better performance.
  # Case-insensitive.
  contains
  # Match if the target string field exactly matches the
  # supplied value. Case-insensitive.
  exact
}

input SendEmail {
  from: String!
  to: String!
  subject: String!
  # Message can be either text or HTML
  message: String!
  replyTo: String!
}

# Contains information of a event hook
type Trigger {
  id: ID!
  event: String!
  target: String!
  consumerParams: JSONData
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  createdBy: String!
  updatedBy: String!
}

input CreateTriggers {
  # List of events in csv form. Use "*" to listen to all events. When using a wild card, csv form is no longer valid.
  # Either events or types can be specified at a time. Example:
  #
  # events: "event1,event2,event3" // valid
  #
  # events: "*" // valid
  #
  # events: "*,event1" // invalid
  events: String

  # List of events in csv form. Use "*" to listen to all types. When using a wild card, csv form is no longer valid.
  # Either events or types can be specified at a time. Example:
  #
  # types: "type1,type2,type3" // valid
  #
  # types: "*" // valid
  #
  # types: "*,type1" // invalid
  types: String

  # Array of hook targets
  targets: [CreateTriggerType]
}

type ExportRequest {
  # The unique ID of this export request
  id: ID!
  # Current status of this export request
  status: ExportRequestStatus!
  # ID of the organization this export request was issued for
  organizationId: ID!
  # Date/time at which this export request was created
  createdDateTime: DateTime!
  # Date/time at which this export request was last modified
  modifiedDateTime: DateTime!
  # ID of the user or API key that created this export request
  requestorId: ID!
  # The signed URI to the object that contains, or will contain,
  # export results.
  assetUri: String
}

enum ExportRequestStatus {
  incomplete
  complete
  downloaded
}

input CreateExportRequestForTDO {
  # ID of the TDO to export from
  # Either this option _or_ mentionId must be provided.
  # This option must be provided if includeMedia is set to true on CreateExportRequest
  tdoId: ID
  # ID of the mention to export from
  # Either this option _or_ tdoId must be provided.
  mentionId: ID
  # optional start offset in milliseconds for the export, relative to TDO startDateTime
  startOffsetMs: Int
  # optional stop offset in milliseconds for the export, relative to the TDO stopDateTime.
  stopOffsetMs: Int
  # optional start date for the exported results. Takes priority over startOffsetMs.
  startDate: DateTime
  # optional end date for the exported results. Takes priority over stopOffsetMs.
  stopDate: DateTime
}

input CreateExportRequestFormatConfig {
  # The file extension of the export type, such as "vlf" or "ttml".
  # Must be supported by the requested engine category.
  extension: String!
  # Optional export options specific to the target engine category.
  options: JSONData
}

input CreateExportRequestOutputConfig {
  # ID of an individual engine to export results for.
  # Either this option _or_ categoryId must be provided.
  engineId: ID
  # ID of an engine category to export results for.
  # Either this option _or_ engineId must be provided.
  categoryId: ID
  # Export output format configuration
  formats: [CreateExportRequestFormatConfig!]!
}

input CreateExportRequest {
  # Whether or not to include TDO media assets in the export.
  # Setting this option can greatly increase the size of the export file.
  includeMedia: Boolean = false
  # Information on the TDOs to export data from
  tdoData: [CreateExportRequestForTDO!]!
  # Information on the export output configuration
  outputConfigurations: [CreateExportRequestOutputConfig!] = []
}

input UpdateExportRequest {
  # ID of the export request to update
  id: ID!
  # Status change
  status: ExportRequestStatus
  # The asset URI
  assetUri: String
}

input CreateTriggerType {
  # The name of the trigger target. Currently we only support
  # Webhook, SMS, and Email
  name: CreateTriggerTarget!
  # The parameters for this hook. Must be a JSON payload. See
  # HookTarget docs for supported kvp for each HookTarget type.
  params: JSONData!
}

enum CreateTriggerTarget {
  # Webhook target should provide the following kvp in the json structure of
  # TargetType:params
  #
  # "url":"<protocol>://<your_url>"
  Webhook
  # SMS target should provide the following kvp in the json structure of
  # TargetType:params
  #
  # "number": ########
  SMS
  # Email target should provide the following kvp in the json structure of
  # TargetType:params
  #
  # "address":"<your_address>@<your_domain>"
  Email
}

type AuditLogEntry {
  # ID of the organization that generated the audit entry.
  organizationId: ID
  # The type of the object involved in the audit action, such as `Watchlist`
  # or `TemporalDataObject`.
  objectType: String
  # The ID of the object involved in the audit action. The format of this ID
  # varies by object type.
  objectId: ID
  # The unique ID of the audit log entry.
  id: ID!
  # The event type, such as `Create`, `Update`, or `Delete`.
  eventType: String
  # User name or ID that generated the audit entry. This might be an API key.
  userName: String
  # Indicates whether or not the attempted action was successful.
  success: Boolean
  # IP address of the client that generated the audit action.
  clientIpAddress: String
  # HTTP user agent of the client that generated the audit action.
  clientUserAgent: String
  description: String
  # Date/time at which the audit log entry was created.
  createdDateTime: DateTime!
}

type AuditLogEntryList implements Page {
  records: [AuditLogEntry!]!
  # Count of records in this page. Will be less than or equal to `limit`.
  count: Int
  # Offset used in the query that generated this page.
  offset: Int!
  # Limit used in the query that generated this page.
  limit: Int!
  # `toDateTime` value of the query that generated this page.
  # Useful when a default was applied.
  toDateTime: DateTime
  # `fromDateTime` value of the query that generated this page.
  # Useful when a default was applied.
  fromDateTime: DateTime
}

type Event {
  id: ID!
  eventName: String!
  eventType: String!
  application: String!
  public: Boolean!
  description: String
  schemaData: String!
  schemaHash: String!
  createdDateTime: DateTime!
  createdBy: String!
}

input EventDelivery {
  name: EventDeliveryType!
  params: JSONData!
}

type UnsubscribeEvent {
  # ID of the object that was deleted
  id: ID!
  # Message
  message: String
}

enum EventDeliveryType {
  # Webhook protocol should provide the following kvp in the json structure of
  # "url":"<protocol>://<your_url>"
  # "encoding":"[protobuf|protobuf_base64|json]
  # "template": string
  Webhook
  # SMS protocol should provide the following kvp in the json structure of
  # "number": ##########
  SMS
  # Email protocol should provide the following kvp in the json structure of
  # "address":"<your_address>@<your_domain>"
  Email
}

input CreateEvent {
  # Name of the event to be created
  eventName: String!
  # The type of event
  eventType: String!
  # Identifier of the app using the event. Using "system" as application will throw error
  application: String!
  # Event visibility. Private event is only visible to the app publisher.
  public: Boolean! = false
  # General description of the event
  description: String
  # Optional schema. Accept on Protocol buffer format. If not provided,
  # Custom message schema is inferred
  schemaData: String
}

input UpdateEvent {
  # ID of event
  id: ID!
  # General description of the event
  description: String
}

input SubscribeEvent {
  # Existing event name
  eventName: String
  # Existing event type
  eventType: String
  # Identifier of the app using the event
  application: String!
  # a string payload, it should be serialized Protobuf data with base64 encoding
  delivery: EventDelivery!
}

input EmitEvent {
  # Event name
  eventName: String!
  # Existing event type
  eventType: String!
  # Identifier of the app using the event
  application: String!
  # string payload, it should be serialized Protobuf data with base64 encoding or escaped JSON string
  payload: String!
}

type EmitEventResponse {
  id: ID!

  # the decoder that GQL used to interpret your event before sending
  decoder: String!
}

type WorkflowRuntimeResponse {
  success: Boolean!

  # Error message if success is false
  message: String

  # uri of veritone workflow instance.
  # This is only available when Workflow request is successful
  uri: String
}

type WorkflowRuntimeStorageData {
  # Unique lookup id for the workflowRuntimeData
  storageKey: String!
  # Data content - base64 encoded binary, plain string or encoded JSON
  storageData: String!
  # Optional metadata for the workflowRuntimeData
  storageMetadata: String
}

input CreateWorkflowRuntimeStorageData {
  # Unique lookup id for the workflowRuntimeData
  storageKey: String!
  # Data content - base64 encoded binary, plain string or encoded JSON
  storageData: String!
  # Optional metadata for the workflowRuntimeData
  storageMetadata: String
}

type WorkflowRuntimeStorageDataList implements Page {
  records: [WorkflowRuntimeStorageData]
  count: Int
  offset: Int!
  limit: Int!
}
