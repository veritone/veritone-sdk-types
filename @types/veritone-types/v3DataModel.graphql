type ScheduledJob {
  id: ID!
  organizationId: ID

  # Organization that owns this scheduled job
  organization: Organization

  name: String
  description: String

  startDateTime: DateTime
  stopDateTime: DateTime

  jobPipelineIds: [ID!]
  jobPipelines(offset: Int = 0, limit: Int = 30): JobPipelineList!

  jobTemplateIds: [ID!]
  jobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  # Retrieve the complete set of job templates associated with this
  # scheduled job, including those that are associated through a job
  # pipeline.
  allJobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  # The ID of the primary source on this scheduled job, if applicable.
  # This is based on the payloads of the tasks that are invoked for
  # this scheduled job.
  primarySourceId: ID

  # The primary source. See `primarySourceId` above.
  primarySource: Source

  jobs(
    # Optionally, specify a TDO ID to filter by job target
    targetId: ID
    # Optionally, specify a cluster ID to filter by cluster
    clusterId: ID
    # Provide sort information. The default is to sort by
    # createdDateTime descending.
    orderBy: [JobSortField!]
    # Optionally, specify filters on date/time fields
    dateTimeFilter: [JobDateTimeFilter!]
    # Provide a list of status strings to filter by status
    status: [JobStatusFilter!]
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify the maximum number of results to included in this response, or page size.
    limit: Int = 30
  ): JobList!

  # Get a list of sources that are used
  # by engine configurations that reference
  # this schedule through the schedule -> job -> task relationship.
  sources(offset: Int = 0, limit: Int = 30): SourceList

  parts: [SchedulePart!]

  isActive: Boolean!

  runMode: RunMode!

  details: JSONData

  detailsSchemaId: ID

  createdDateTime: DateTime

  modifiedDateTime: DateTime

  # List of schema-controlled content templates attached
  # to this scheduled job
  contentTemplates: [ScheduledJobContentTemplate!]!

  # Permissions granted to other organizations. Only the source owner
  # can view or edit this field.
  collaborators: ScheduledJobCollaboratorList!

  # A public scheduled job can be viewed and launched by
  # users from any organization. By default, scheduled jobs are
  # private and can only be viewed or launched by the owning organization
  # and organizations that the owner has explicitly shared them with.
  # Only Veritone administrators can create public scheduled jobs.
  isPublic: Boolean

  # The user's permission on this scheduled job
  permission: ScheduledJobPermission

  primarySourceTypeId: ID

  primarySourceType: SourceType

  ingestionStatusId: ID
  ingestionStatus: String

  affiliates: ProgramAffiliateList!
}

input CreateProgramAffiliate {
  sourceId: ID!
  scheduledDay: DayOfWeek!
  startDateTime: DateTime!
  stopDateTime: DateTime!
  startTime: Time!
  stopTime: Time!
}

type ProgramAffiliate {
  sourceId: ID!
  source: Source
  scheduledJobId: ID!
  scheduledJob: ScheduledJob
  scheduledDay: DayOfWeek
  startDateTime: DateTime
  stopDateTime: DateTime
  startTime: Time
  stopTime: Time
  status: String
}

type ProgramAffiliateList implements Page {
  records: [ProgramAffiliate!]
  offset: Int!
  limit: Int!
  count: Int
}

input ScheduledJobOrderBy {
  field: ScheduledJobOrderField!
  direction: OrderDirection = desc
}

enum ScheduledJobOrderField {
  id
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
  name
  runMode
  isActive
}

# A source ACL grants a single organization limited rights to a private source
type ScheduledJobCollaborator {
  # The permission granted. Either `viewer` or `editor`.
  permission: ScheduledJobPermission!
  # Organization ID the source was shared with
  organizationId: ID!
  # The organization the source was shared with
  organization: Organization
}

type ScheduledJobCollaboratorList implements Page {
  records: [ScheduledJobCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum SetScheduledJobPermission {
  viewer
  editor
  none
}

input CreateScheduledJobCollaborator {
  # ID of the organization to share the source with
  organizationId: ID!
  # Permission to grant. Can be `editor` or `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetScheduledJobPermission!
}

# Permissions or roles on source objects
enum ScheduledJobPermission {
  # A source editor can make updates to some source fields, but cannot
  # delete or share the source.
  editor
  # A viewer can view the source and use it in ingestion jobs,
  # but not make any updates to it.
  viewer
  # A source owner has full rights to update and delete the source.
  owner
}

enum RunMode {
  Continuous
  Recurring
  Once
  Now
}

enum ScheduleType {
  Weekly
  Interval
}

type SchedulePart {
  scheduleType: ScheduleType!

  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time

  #  startDateTime: DateTime
  #  stopDateTime: DateTime

  repeatIntervalUnit: IntervalUnit
  repeatInterval: Int
  durationSeconds: Int
}

enum IntervalUnit {
  Months
  Weeks
  Days
  Hours
  Minutes
  Seconds
}

input CreateRecurringSchedulePart {
  repeatIntervalUnit: IntervalUnit!
  repeatInterval: Int!
  durationSeconds: Int

  # Time of day, required for repeat interval unit in days.
  startTime: Time
}

input CreateWeeklySchedulePart {
  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time
}

input CreateScheduledJob {
  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]

  jobTemplates: [CreateJobTemplate!]

  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]

  name: String!
  # A detailed description. Defaults to name.
  description: String
  runMode: RunMode = Once
  # JSON containing metadata details for this scheduled job.
  # If supplied, then the detailsSchemaId must also be set.
  # The supplied data must comply with the schema
  details: JSONData
  # Schema ID for detail metadata on this scheduled job
  detailsSchemaId: ID

  isActive: Boolean = true

  startDateTime: DateTime
  stopDateTime: DateTime

  # Optionally, associate content templates with the new scheduled job
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  # Organization ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  organizationId: ID

  # Indicates whether or not the scheduled job is publicly accessible.
  # Only Veritone administrators can create public scheduled jobs.
  # Other users will get an error if they attempt to set this value to true.
  isPublic: Boolean = false

  affiliates: [CreateProgramAffiliate!]
}

input CloneScheduledJob {
  id: ID!

  # Organization ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  organizationId: ID
}

input RevertScheduledJob {
  id: ID!
}

input UpdateScheduledJob {
  id: ID!

  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]

  # Optionally, specify the job template definitions here.
  jobTemplates: [CreateJobTemplate!]

  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]

  name: String
  # A detailed description. Defaults to name.
  description: String
  runMode: RunMode
  # JSON containing metadata details for this scheduled job.
  # If the scheduled job does not already have a schema ID
  # associated with, one must be supplied along with this data.
  # In either case, the supplied data must comply with the
  # schema.
  details: JSONData
  # ID of the schema for detail metadata on this scheduled job
  detailsSchemaId: ID
  isActive: Boolean

  startDateTime: DateTime
  stopDateTime: DateTime

  # Optionally, associate content templates with the new scheduled job
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  # Indicates whether or not the scheduled job is publicly accessible.
  # Only Veritone administrators can create public scheduled jobs.
  # Other users will get an error if they attempt to set this value to true.
  isPublic: Boolean = false

  affiliates: [CreateProgramAffiliate!]

  # Indicates whether or not the scheduled job we should upgrade this schedule job
  # to the new data model if an upgrade is possible.
  migrateIfLegacy: Boolean = false
}

type ScheduledJobList implements Page {
  records: [ScheduledJob!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type Cluster {
  id: ID!
  nodes: [ClusterNode]
  name: String
  isPublic: Boolean
  type: ClusterType
  organizationId: ID
  allowedEngines: [ID!]
  containerTag: String
  paused: Boolean
  memorySizeBytes: Float
  storageSizeBytes: Float
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  deletedDateTime: DateTime
  cachedDateTime: DateTime
  default: Boolean
  bypassAllowedEngines: Boolean
  collaborators: ClusterCollaboratorList
}

enum ClusterType {
  # Amazon Machine Image
  ami
  # Real-Time
  RT
}

input CreateCluster {
  name: String!
  allowedEngines: [String]!
  dockerCredentials: JSONData!
  type: ClusterType
  containerTag: String
  paused: Boolean
  # Specify memory size in raw bytes or in human-readable
  # format such as 8gb, 1024mb, etc.
  memorySize: String
  # Specify storage size in raw bytes or in human-readable
  # format such as 8gb, 1024mb, etc.
  storageSize: String
  bypassAllowedEngines: Boolean

  # Permissions granted to other organizations. Only the cluster owner
  # can view or edit this field.
  collaborators: [CreateClusterCollaborator!]
}

input UpdateCluster {
  id: ID!
  name: String
  allowedEngines: [String]
  dockerCredentials: JSONData
  containerTag: String
  memorySize: Int
  storageSize: Int
  bypassAllowedEngines: Boolean

  # Permissions granted to other organizations. Only the cluster owner
  # can view or edit this field.
  collaborators: [CreateClusterCollaborator!]
}

# A source ACL grants a single organization limited rights to a private clusters
type ClusterCollaborator {
  # The permission granted.
  permission: ClusterPermission!
  # Organization ID the cluster was shared with
  organizationId: ID!
  # The organization the cluster was shared with
  organization: Organization
}

type ClusterCollaboratorList implements Page {
  records: [ClusterCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum ClusterPermission {
  owner
  viewer
}

enum SetClusterPermission {
  viewer
  none
}

input CreateClusterCollaborator {
  # ID of the organization to share
  organizationId: ID!
  # Permission to grant cluster. Can be `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetClusterPermission!
}

input PauseCluster {
  id: ID!
}

input UnpauseCluster {
  id: ID!
}

type ClusterList implements Page {
  records: [Cluster!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ClusterNode {
  id: ID!
  clusterId: ID
  cluster: Cluster
  name: String
}

input CreateClusterNode {
  name: String
  clusterId: ID
  metrics: CreateMetrics!
  containerTag: String
  offlineBrowsing: Boolean
  storagePresent: Boolean
  type: ClusterType
}

input UpdateClusterNode {
  id: ID!
  name: String
}

type ClusterNodeList implements Page {
  records: [ClusterNode!]!
  count: Int!
  offset: Int!
  limit: Int!
}

input CreateMetrics {
  cpuCount: Int!
  mbRam: Int!
  mbDisk: Int!
  ipExternal: String
  ipInternal: String
  ami: String
  ec2InstanceType: String
  ec2Region: String
  awsAccount: String
  loadAverage: JSONData
}

type EngineConfiguration {
  id: ID!
  credentials: [ExternalCredential!]
  sourceId: ID
  source: Source
}

input CreateEngineConfiguration {
  sourceId: ID!
  credentialIds: [ID!]
}

input UpdateEngineConfiguration {
  id: ID!
  credentialIds: [ID!]
}

type EngineConfigurationList implements Page {
  records: [EngineConfiguration!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ExternalCredential {
  id: ID!
  sourceTypeId: ID
  sourceType: SourceType
  data: StructuredData
  dataId: ID
}

input CreateExternalCredential {
  sourceTypeId: ID
  dataId: ID
}

input UpdateExternalCredential {
  id: ID!
  dataId: ID
}

type ExternalCredentialList implements Page {
  records: [ExternalCredential!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# A source represents a source of data and is used by adapters to ingest
# data into the platform for use by an engine workflow.
type Source {
  # Unique ID of this source
  id: ID!

  # ID of the source type for this source.
  sourceTypeId: ID!

  # The source type for this source
  sourceType: SourceType
  # A name for this source
  name: String!
  # Metadata associated with this source. The schema for this data is
  # specific to the source type and controlled by a schema.
  details: JSONData
  # Indicates whether this source is public and available to all organizations
  # or restricted to the organization that owns id.
  isPublic: Boolean!
  # ID of the organization that owns this source
  organizationId: ID!
  # The organization that owns this source
  organization: Organization
  # Date and time this source was created
  createdDateTime: DateTime
  # Date and time this source was last modified
  modifiedDateTime: DateTime
  # An optional thumbnail image URL for the source
  thumbnailUrl: String

  contentTemplates: [SourceContentTemplate!]!
  # Id of a published data registry schema
  correlationSchemaId: ID
  # Id of a structured data object for the correlationSchemaId
  correlationSDOId: ID

  # permission the currently authenticated principal has on this source.
  permission: SourcePermission!

  # Permissions granted to other organizations. Only the source owner
  # can view or edit this field.
  collaborators(
    orderBy: SourceCollaboratorOrderBy = organizationId
    orderDirection: OrderDirection = asc
  ): SourceCollaboratorList!

  # Current state for the source object. This is controlled by
  # the adapters that use the source and should not be set by
  # other clients.
  state: JSONData
}

enum SourceCollaboratorOrderBy {
  organizationId
  permission
}

# A source ACL grants a single organization limited rights to a private source
type SourceCollaborator {
  # The permission granted. Either `viewer` or `editor`.
  permission: SourcePermission!
  # Organization ID the source was shared with
  organizationId: ID!
  # The organization the source was shared with
  organization: Organization
}

type SourceCollaboratorList implements Page {
  records: [SourceCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum SetSourcePermission {
  viewer
  editor
  none
}

input CreateSourceCollaborator {
  # ID of the organization to share the source with
  organizationId: ID!
  # Permission to grant. Can be `editor` or `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetSourcePermission!
}

# Permissions or roles on source objects
enum SourcePermission {
  # A source editor can make updates to some source fields, but cannot
  # delete or share the source.
  editor
  # A viewer can view the source and use it in ingestion jobs,
  # but not make any updates to it.
  viewer
  # A source owner has full rights to update and delete the source.
  owner
}

# Data used to create a new source
input CreateSource {
  # The source type ID
  sourceTypeId: ID!
  # The human-readable source name. The value does not have to be unique,
  # but it is strongly recommended to use a name that is unique within
  # the owning organization.
  name: String!
  # Indicates whether or not the source is public. Default is false (private
  # to owner organization).
  isPublic: Boolean = false
  # Additional metadata to associate with the source. This data may be
  # validated against a schema associated with the source type.
  details: JSONData

  # Optional thumbnail image URL for the source
  thumbnailUrl: String

  # Optionally, associate content templates with the new source
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  # Optionally associate a schema for correlation.
  # Required when correlationSDOId is specified.
  correlationSchemaId: ID
  # Optionally associate a structured data object of the specified correlationSchemaId.
  # Required when correlationSchemaId is specified.
  correlationSDOId: ID

  # Add or modify collaborators on the source.
  collaborators: [CreateSourceCollaborator!]
  # Optionally, set an initial state for the source.
  # This is typically not required.
  state: JSONData
}

# Data used to update an existing source
input UpdateSource {
  # The ID of the source to update
  id: ID!
  # Update the name field
  name: String
  # Update the isPublic field
  isPublic: Boolean
  # Additional metadata to associate with the source. This data may be
  # validated against a schema associated with the source type.
  details: JSONData

  # Optional thumbnail image URL for the source
  thumbnailUrl: String

  # Optionally, associate content templates with the new source
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  # Optionally associate a schema for correlation.
  # Required when correlationSDOId is specified.
  correlationSchemaId: ID
  # Optionally associate a structured data object of the specified correlationSchemaId.
  # Required when correlationSchemaId is specified.
  correlationSDOId: ID

  # Add or modify collaborators on the source. Permissions for organizations
  # not mentioned in this list will _not_ be modified. To revoke permissions
  # for an organization, use the `none` permission.
  collaborators: [CreateSourceCollaborator!]
  # Set current state for the source. This is used only by the adapters
  # that use the source and should not be set by other clients.
  state: JSONData
  # @scopes(scopes: ["task_type:internal", "superadmin"], require: Any)
}

type SourceList implements Page {
  records: [Source!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type SourceContentTemplate {
  id: ID!
  sourceId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSONData
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

input CreateSourceContentTemplate {
  # Specify the source ID that this content template applies to
  sourceId: ID!
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!
  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID
  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSONData
}

input CreateSourceContentTemplateWithSource {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!
  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID
  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSONData
}

type ScheduledJobContentTemplate {
  id: ID!
  scheduledJobId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSONData
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

input CreateScheduledJobContentTemplate {
  # Specify the scheduled job ID that this content template applies to
  scheduledJobId: ID!
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!
  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID
  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSONData
}

input CreateScheduledJobContentTemplateWithScheduledJob {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!
  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID
  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSONData
}

# A source type represents a category of sources that share common
# attributes, such as "TV station" or "Real-time camera feed".
type SourceType {
  # Unique ID of this source type
  id: ID!
  # A name for this source type
  name: String!
  organizationId: ID
  isPublic: Boolean
  # The ID of an optional schema for instances (sources) of
  # this source type
  sourceSchemaId: ID
  # The icon representing the type of source
  iconClass: String
  # The schema object used to validate details for instances (sources)
  # of this source type
  sourceSchema: Schema
  # The ID of an optional schema for credentials associated with
  # sources of this type.
  credentialSchemaId: ID
  # The schema used to validate credentials associated with sources
  # of this type.
  credentialSchema: Schema
  # Date and time this object was created.
  createdDateTime: DateTime
  # Date and time this object was last modified
  modifiedDateTime: DateTime

  credentialType: CredentialType

  # Indicates whether or not the source is "live", such as a camera feed
  isLive: Boolean

  # Indicates whether the source requires a scan job pipeline
  requiresScanPipeline: Boolean

  supportedRunModes: [RunMode!]!

  # The source type category ID for this source type.
  # Used primarily by Veritone platform components.
  categoryId: ID!
  # The source type category for this source type.
  # Used primarily by Veritone platform components.
  category: SourceTypeCategory!

  # List of source formats applicable to this source type.
  # Only applies to certain source types; many will have an
  # empty list.
  sourceFormats: [String!]!

  # List of program formats applicable to this source type.
  # Only applies to certain source types; many will have an
  # empty list.
  programFormats: [String!]!

  # Sources created under this source type
  sources(
    # Optionally, provide a list of IDs to retrieve sources by ID
    id: [ID!]
    # Provide a name or partial name value to filter by name.
    # The `nameMatch` parameter can be used to determine the string
    # match strategy used in the filter. Default is "starts with".
    # Note that all matching is case-insensitive.
    name: String
    # String matching strategy. Default is "starts with".
    nameMatch: StringMatch = startsWith
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0
    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    # Set this flag to true or false to return only sources that do or do
    # not have content templates associated with them.
    # The default is neither (do not filter on the presence of content templates).
    hasContentTemplates: Boolean
    # Set this flag to true to include public sources or false to include
    # only sources owned by the
    # user's org, not public sources.
    # Public sources owned by the caller's org will always be returned.
    includePublic: Boolean = true
    #Provide a correlation schama ID to filter for sources that correlate using specified schema.
    correlationSchemaId: ID
    # Provide optional sort information. If not provided, a default sort
    # by createdDateTime descending will be applied.
    orderBy: [SourceSortField!]
  ): SourceList!
}

# Source type categories are managed by Veritone.
type SourceTypeCategory {
  id: ID!
  name: String!
}

type SourceTypeCategoryList implements Page {
  records: [SourceTypeCategory!]!
  limit: Int!
  offset: Int!
  count: Int
}

enum CredentialType {
  None
  Any
  APIKey
  Username
}

input CreateSourceType {
  sourceSchemaId: ID
  credentialSchemaId: ID
  name: String!
  details: JSONData
  credentialType: CredentialType = None
  # Indicates that the source type is publicly accessible.
  # If false, is usable only by the owner organization.
  isPublic: Boolean = False
  # Indicates whether or not the source type is "live", such
  # as a camera feed
  isLive: Boolean = False
  # Indicates whether or not the source type requires
  # scan pipeline jobs
  requiresScanPipeline: Boolean = false
  # Source type category ID
  categoryId: ID!
}

input UpdateSourceType {
  id: ID!
  name: String
  sourceSchemaId: ID
  credentialSchemaId: ID
  details: JSONData
  credentialType: CredentialType
  # Indicates that the source type is publicly accessible.
  # If false, is usable only by the owner organization.
  isPublic: Boolean
  # Indicates whether or not the source type is "live", such
  # as a camera feed
  isLive: Boolean = False
  # Indicates whether or not the source type requires
  # scan pipeline jobs
  requiresScanPipeline: Boolean = false
  # Source type category ID
  categoryId: ID
}

type SourceTypeList implements Page {
  records: [SourceType!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ExecutionLocation {
  id: ID!
  clusterId: ID!
  cluster: Cluster!
  nodeId: ID
  node: ClusterNode
  data: JSONData!
}

type CreateExecutionLocation {
  clusterId: ID!
  nodeId: ID
}

type UpdateExecutionLocation {
  id: ID!
  clusterId: ID!
  nodeId: ID
}

type ExecutionLocationList implements Page {
  records: [ExecutionLocation!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# A job template is a reusable template for job creation.
type JobTemplate {
  # The object ID
  id: ID!
  # Date and time this job template was created
  createdDateTime: DateTime
  # Date and time this job template was last modified
  modifiedDateTime: DateTime
  # Task templates associated with this job template
  taskTemplates(engineType: [EngineTypeFilter!], engineId: ID, offset: Int = 0, limit: Int = 30): TaskTemplateList!
  # Job pipeline ID that this template belongs to, if there is one
  jobPipelineId: ID
  # Job pipeline that this template belongs to, if there is one
  jobPipeline: JobPipeline
  # Job pipeline stage. Defined only if this template belongs to a job pipeline.
  jobPipelineStage: Int
  # Target execution cluster ID
  clusterId: ID
  skipDecider: Boolean

  # Optional configuration data for jobs launched from the template.
  # A schema may be enforced over the data stored here.
  # Used for top-level information about the job that does not fit on
  # a specific task template.
  jobConfig: JSONData
}

input CreateJobTemplate {
  # The set of task template definitions for this job template.
  taskTemplates: [CreateTaskTemplate!]
  # Optional. Specify a job pipeline ID if this job template is associated
  # with a job pipeline.
  jobPipelineId: ID
  # Optional. Should be set only if `jobPipelineId` is set.
  # Specifies the stage in the pipeline at which this job template should
  # be applied.
  jobPipelineStage: Int
  # Used only by Veritone platform components.
  skipDecider: Boolean
  # Optional job-level configuration. Typically used only by Veritone
  # platform components.
  jobConfig: JSONData
  # Application ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  applicationId: ID

  clusterId: ID
}

input UpdateJobTemplate {
  id: ID!
  #taskTemplates: [CreateTaskTemplate!]
  jobPipelineStage: Int
  skipDecider: Boolean
  jobConfig: JSONData
}

type JobTemplateList implements Page {
  records: [JobTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type TaskTemplate {
  id: ID!
  engineId: ID
  engine: Engine
  engineConfigId: ID
  engineConfig: EngineConfiguration
  executionLocationId: ID
  executionLocation: ExecutionLocation
  jobTemplateId: ID
  jobTemplate: JobTemplate
  payload: JSONData
  payloadString: String
  parentTaskId: ID

  parentTask: Task
  childTaskIds: [ID!]!
  childTasks: TaskTemplateList!
}

input CreateTaskTemplate {
  engineId: ID
  engineConfigId: ID
  executionLocationId: ID
  jobTemplateId: ID
  payload: JSONData
  payloadString: String
  parentTaskId: ID
}

input UpdateTaskTemplate {
  id: ID!
  payload: JSONData
  payloadString: String
  parentTaskId: ID
}

type TaskTemplateList implements Page {
  records: [TaskTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type JobPipeline {
  # Unique ID of this job pipeline
  id: ID!
  # List of job templates associated with this job pipeline
  jobTemplates: JobTemplateList
  # ID of the organization that owns this job pipeline
  organizationId: ID
  # The organization that owns this job pipeline
  organization: Organization
  # Indicates whether or not this job pipeline is public. If so, it can
  # be viewed and used, but not modified, by all organizations.
  isPublic: Boolean!
}

input CreateJobPipeline {
  jobTemplateIds: [ID!]
  isPublic: Boolean = false
}

input UpdateJobPipeline {
  id: ID!
  jobTemplateIds: [ID!]
  isPublic: Boolean
}

type JobPipelineList implements Page {
  records: [JobPipeline!]!
  count: Int!
  offset: Int!
  limit: Int!
}

extend type Task {
  engineConfiguration: EngineConfiguration
  engineConfigurationId: ID
  executionLocation: ExecutionLocation
  executionLocationId: ID
  templateId: ID
  template: TaskTemplate
}

extend type Job {
  # ID of the template from which this job was created, if applicable.
  templateId: ID
  # The template which this job was created, if applicable.
  template: JobTemplate
  # ID of the scheduled job under which this job was created, if applicable.
  scheduledJobId: ID
  # The scheduled job under which this job was created, if applicable.
  scheduledJob: ScheduledJob
}

extend type Watchlist {
  # Contains the list of all source type IDs
  # associated with this watchlist, including
  # those for sources on schedules.
  combinedSourceTypeIds: [ID!]
  scheduledJobs(offset: Int = 0, limit: Int = 30): ScheduledJobList!

  # TODO for backward compat with v3 search?
  schedules(offset: Int = 0, limit: Int = 30): ScheduledJobList!
}

extend type TDOSourceData {
  # The scheduled job under which this TDO was created, if any
  scheduledJob: ScheduledJob
  # The source from which this TDO was created, if any
  source: Source
}

# extend type Query {
#   # Retrieve a single schedule
#   scheduledJob(id: ID!): ScheduledJob
#   # Retrieve or search for schedules
#   scheduledJobs(
#     # Provide an ID to retrieve a specific schedule
#     id: ID
#     # Provide a schedule name, or part of one, to search for schedules
#     # by name. Supports prefix/like search.
#     name: String
#     # Specify a run mode to filter to run mode
#     runMode: RunMode
#     # Specify isActive true or false to filter by active state
#     isActive: Boolean
#     engineId: ID
#     engineCategoryId: ID
#     engineType: [EngineTypeFilter!]
#     # Specify an offset to retrieve additional pages
#     offset: Int = 0
#     # Specify a limit to limit result size.
#     limit: Int = 30
#     dateTimeFilter: [ScheduledJobDateTimeFilter!]

#     # Time filter is in station local time
#     partTimeFilter: [ScheduledJobPartTimeFilter!]

#     # Optionally, specify one or more source IDs. Scheduled jobs with
#     # any of the given sources as their primary source will be returned.
#     primarySourceId: [ID!]
#     # Optionally, specify one or more source type IDs. Scheduled jobs with
#     # any of the given sources types on their primary source will be returned.
#     primarySourceTypeId: [ID!]

#     hasJobTemplate: Boolean

#     # Specify isRunning true or false to filter for scheduled jobs that
#     # have jobs running right now.
#     hasRunningJobs: Boolean

#     # Order information. Default will order by modifiedDateTime descending.
#     orderBy: [ScheduledJobOrderBy!]

#     # Specify a permission level to retrieve scheduled jobs to which you
#     # have at least that permission.
#     permission: ScheduledJobPermission = viewer
#   ): ScheduledJobList
#   # Retrieve a single engine configuration
#   engineConfiguration(id: ID!): EngineConfiguration
#   # Retrieve all engine configurations
#   engineConfigurations(id: ID): EngineConfigurationList
#   # Retrieve a single node
#   clusterNode(id: ID!): ClusterNode!
#   # Retrieve a list of nodes
#   clusterNodes(id: ID, offset: Int = 0, limit: Int = 30): ClusterNodeList!
#   # Retrieve a single cluster
#   cluster(id: ID!): Cluster!
#   # Retrieve a list of clusters
#   clusters(id: ID, name: String, type: ClusterType, offset: Int = 0, limit: Int = 30): ClusterList!
#   # Retrieve a single execution location
#   executionLocation(id: ID!): ExecutionLocation!
#   # Retrieve a list of execution locations
#   executionLocations(id: ID): ExecutionLocationList!
#   # Retrieve a single job template
#   jobTemplate(id: ID!): JobTemplate!
#   # Retrieve a list of job templates for a given job pipelineId
#   jobTemplates(
#     jobPipelineId: ID
#     scheduledJobId: ID
#     engineId: ID
#     engineType: [EngineTypeFilter!]
#     offset: Int = 0
#     limit: Int = 30
#   ): JobTemplateList!
#   # Retrieve a single task template
#   taskTemplate(id: ID!): TaskTemplate!
#   # Retrieve a single job pipeline
#   jobPipeline(id: ID!): JobPipeline!
#   # Retrieve a list of job pipelines owned by org
#   jobPipelines(id: ID, scheduledJobId: ID, isPublic: Boolean, offset: Int = 0, limit: Int = 30): JobPipelineList!
#   # Retrieve a single source
#   source(id: ID!): Source!
#   # @scopes(
#   #   scopes: [
#   #     "cms.access"
#   #     "discovery.access"
#   #     "cms.sources.read"
#   #     "cms.customerservice"
#   #   ]
#   #   require: Any
#   # )
#   # # @auth(allowOrgless: true, skipObjectAuthorization: true)
#   # Retrieve a list of sources
#   sources(
#     # Provide an ID to retrieve a specific source.
#     id: ID
#     # Provide a source type ID to filter for sources of the specified type.
#     sourceTypeId: ID
#     sourceTypeIds: [ID]
#     # Provide a name or partial name value to filter by name.
#     # The `nameMatch` parameter can be used to determine the string
#     # match strategy used in the filter. Default is "starts with".
#     # Note that all matching is case-insensitive.
#     name: String
#     # String matching strategy. Default is "starts with".
#     nameMatch: StringMatch = startsWith
#     # Provide an offset to skip to a certain element in the result, for paging.
#     offset: Int = 0
#     # Specify maximum number of results to retrieve in this result. Page size.
#     limit: Int = 30
#     # Set this flag to true or false to return only sources that do or do
#     # not have content templates associated with them.
#     # The default is neither (do not filter on the presence of content templates).
#     hasContentTemplates: Boolean
#     # Set this flag to true to include public sources or false to include
#     # only sources owned by the
#     # user's org, not public sources.
#     # Public sources owned by the caller's org will always be returned.
#     includePublic: Boolean = true
#     #Provide a correlation schama ID to filter for sources that correlate using specified schema.
#     correlationSchemaId: ID
#     # Provide optional sort information. If not provided, a default sort
#     # by createdDateTime descending will be applied.
#     orderBy: [SourceSortField!]
#     # Specify a permission level to retrieve sources to which you
#     # have at least that permission.
#     permission: SourcePermission = viewer
#   ): SourceList!
#   # @scopes(
#   #   scopes: [
#   #     "cms.access"
#   #     "discovery.access"
#   #     "cms.sources.read"
#   #     "cms.customerservice"
#   #   ]
#   #   require: Any
#   # )
#   # # @auth(allowOrgless: true, skipObjectAuthorization: true)
#   # Retrieve a single source type
#   sourceType(id: ID!): SourceType!
#   # Retrieve a list of source types
#   sourceTypes(
#     id: ID
#     ids: [ID]
#     # Provide a source type category ID to select source types belonging
#     # to the category
#     categoryId: ID
#     # Provide `isLive` to select source types with the given value.
#     isLive: Boolean
#     offset: Int = 0
#     limit: Int = 30
#   ): SourceTypeList!
#   # Retrieve all source type categories
#   sourceTypeCategories(
#     # Optionally, provide a source category type ID.
#     id: ID
#   ): SourceTypeCategoryList!
#   # Retrieve a single source type category
#   sourceTypeCategory(id: ID!): SourceTypeCategory!
#   # Retrieve a single external credential
#   externalCredential(id: ID!): ExternalCredential!
#   # Retrieve a list of external credentials
#   externalCredentials(id: ID): ExternalCredentialList!
#   tasks(id: ID, taskTemplateId: ID): TaskList
# }

# Source list sort information
input SourceSortField {
  # Specify the field to sort by. Required.
  field: SourceOrderField!
  # Specify the sort direction. Default is descending.
  direction: OrderDirection = desc
}

# Source list sort field options
enum SourceOrderField {
  createdDateTime
  modifiedDateTime
  id
  name
  sourceTypeId
}

input ScheduledJobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: ScheduledJobDateTimeField!
  includeEmpty: Boolean
}

enum ScheduledJobDateTimeField {
  startDateTime
  stopDateTime
  dateCreated
  dateModified
}

input ScheduledJobPartTimeFilter {
  toTime: Time
  fromTime: Time
  field: ScheduledJobPartTimeField!
}

enum ScheduledJobPartTimeField {
  startTime
  endTime
}

# extend type Mutation {
#   createCluster(input: CreateCluster!): Cluster

#   updateCluster(input: UpdateCluster!): Cluster

#   deleteCluster(id: ID!): DeletePayload

#   pauseCluster(input: PauseCluster!): Cluster # @audit(action: Update)
#   unpauseCluster(input: UnpauseCluster!): Cluster # @audit(action: Update)
#   createClusterNode(input: CreateClusterNode!): ClusterNode

#   updateClusterNode(input: UpdateClusterNode!): ClusterNode

#   deleteClusterNode(id: ID!): DeletePayload

#   createScheduledJob(input: CreateScheduledJob!): ScheduledJob!

#   cloneScheduledJob(input: CloneScheduledJob!): ScheduledJob!

#   revertScheduledJob(input: RevertScheduledJob!): ScheduledJob!

#   updateScheduledJob(input: UpdateScheduledJob!): ScheduledJob!

#   deleteScheduledJob(id: ID!): DeletePayload

#   # Create a new content template on a scheduled job
#   createScheduledJobContentTemplate(input: CreateScheduledJobContentTemplate!): ScheduledJobContentTemplate!

#   deleteScheduledJobContentTemplate(
#     # ID of the scheduled job content template to delete. It will be removed from the
#     # scheduled job. The underlying SDO will not be deleted.
#     id: ID!
#   ): DeletePayload

#   # Create a new source
#   createSource(input: CreateSource!): Source

#   updateSource(input: UpdateSource!): Source
#   # @scopes(
#   #   scopes: ["cms.access", "cms.sources.update", "source.update"]
#   #   require: Any
#   # )
#   # # @auth(allowOrgless: true)

#   deleteSource(id: ID!): DeletePayload

#   # Create a new source content template on a source
#   createSourceContentTemplate(input: CreateSourceContentTemplate!): SourceContentTemplate!

#   deleteSourceContentTemplate(
#     # ID of the source content template to delete. It will be removed from the
#     # source. The underlying SDO will not be deleted.
#     id: ID!
#   ): DeletePayload

#   createSourceType(input: CreateSourceType!): SourceType
#   # @scopes(scopes: ["superadmin"])

#   updateSourceType(input: UpdateSourceType!): SourceType
#   # @scopes(scopes: ["superadmin"])

#   deleteSourceType(id: ID!): DeletePayload # @scopes(scopes: ["superadmin"])
#   createJobPipeline(input: CreateJobPipeline!): JobPipeline!

#   updateJobPipeline(input: UpdateJobPipeline!): JobPipeline!

#   deleteJobPipeline(id: ID!): DeletePayload

#   createJobTemplate(input: CreateJobTemplate!): JobTemplate!

#   updateJobTemplate(input: UpdateJobTemplate!): JobTemplate!
#   deleteJobTemplate(id: ID!): DeletePayload

#   createTaskTemplate(input: CreateTaskTemplate!): TaskTemplate!

#   updateTaskTemplate(input: UpdateTaskTemplate!): TaskTemplate!

#   deleteTaskTemplate(id: ID!): DeletePayload

#   createNextPipelineJobs(input: CreateNextPipelineJobs!): [Job]
#   # @scopes(scopes: ["job.create"])
#   # @auth(allowOrgless: true, skipObjectAuthorization: true)

#   # Creates one or more jobs based on the supplied scheduled job.
#   launchScheduledJobs(input: LaunchScheduledJobs!): [Job]
#   # @scopes(scopes: ["job.create"])
#   # @audit(action: Create)

#   # Creates one or more jobs based on the supplied job templates.
#   launchJobTemplates(input: LaunchJobTemplates!): [Job]
#   # @scopes(scopes: ["job.create"])
#   # @audit(action: Create)

#   # Get next bundle for cluster.
#   getNextBundleForCluster(input: GetNextBundleForCluster!): Bundle!

#   # Update bundle status as cluster.
#   updateBundleStatusAsCluster(input: updateBundleStatusAsCluster): Bundle!
# }

input CreateNextPipelineJobs {
  jobPipelineId: ID
  parentJobId: ID
  payload: JSONData
  targetInfo: CreateNextPipelineJobsTargetInfo
  # Supply this value if and only if the job pipeline
  # was started as part of a scheduled job.
  scheduledJobId: ID

  organizationId: ID
  applicationId: ID
}

input CreateAllPipelineJobs {
  jobPipelineId: ID!
  jobPipelineStage: Int = 1
  # Optional data about the job target,
  # a TemporalDataObject. If this field is
  # not specified then a suitable
  # object will be created automatically.
  targetInfo: CreateAllPipelineJobsTargetInfo

  # Job payload
  payload: JSONData

  # Supply this value if and only if the job pipeline
  # was started as part of a scheduled job.
  scheduledJobId: ID

  organizationId: ID
  applicationId: ID
}

input LaunchScheduledJobs {
  # Optional data about the job target,
  # a TemporalDataObject. If this field is
  # not specified then a suitable
  # object will be created automatically.
  targetInfo: CreateAllPipelineJobsTargetInfo

  # Optional data used to create a _new_ TDO for the job.
  # Specify this field _or_ `targetInfo`, but not both.
  createTargetInfo: CreateTDOForJob

  # Job payload
  payload: JSONData
  scheduledJobId: ID
}

input CreateTDOForJob {
  # A name for the TDO object, such as the name of the primary media file.
  # If not provided, the TDO will have the name of the scheduled job that
  # created it.
  name: String
  # A description for the TDO object.
  description: String
  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean
  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID
  # Only internal systems can set this value
  applicationId: ID
  # Status, such as "downloaded" or "recording".
  # The server will set a value if one is not provided.
  status: String

  # Detailed metadata about the TDO
  details: JSONData

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String
  # An optional image representing the TDO source
  sourceImageUrl: String
}

input LaunchJobTemplates {
  ids: [ID!]!
  scheduledJobId: ID
  payload: JSONData
  targetInfo: LaunchJobTemplatesTargetInfo
}

input CreateNextPipelineJobsTargetInfo {
  # ID of the target object for the job pipeline,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input CreateAllPipelineJobsTargetInfo {
  # ID of the target object for the job pipeline,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input LaunchJobTemplatesTargetInfo {
  # ID of the target object for the jobs,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

type Bundle {
  id: ID!
  organizationId: ID
  clusterId: ID
  nodeId: ID
  name: String
  externalCredentialId: ID
  testRun: Boolean
  selectDetail: BundleSelectDetail
  selectCategory: String
  bundleResults: BundleResults
  bundleStarted: DateTime
  previousBundleStarted: DateTime
  bundleCompleted: DateTime
  deletedDate: DateTime
  createdDate: DateTime
  updatedDate: DateTime
  scheduleDefinition: BundleScheduleDefinition
  nextScheduledTime: DateTime
}

type BundleScheduleDefinition {
  recurringStartTime: DateTime
  recurringEndTime: DateTime
  repeatDaysTimeInMinutes: Int
  repeatDaysOfWeek: [Int]
  repeatDaysOfMonth: [Int]
  repeatMinutes: Int
}

type BundleResults {
  found: Int!
  completed: Int!
  errors: BundleError!
}

type BundleError {
  error: String!
}

type BundleSelectDetail {
  category: String!
  # Array of file types to include.
  select: [String!]
  # Array of paths to search from.
  paths: [String!]
  # Array of files to search from.
  files: [String]
  # Array of tasks to run for each job.
  tasks: [BundleSelectDetailTask]
  # Include items after this time.
  afterTime: DateTime
  # Include items before this time.
  beforeTime: DateTime
  recursiveDescent: Boolean!
  service: BundleService
}

type BundleSelectDetailTask {
  # Id of engine.
  engineId: ID!
}

type BundleService {
  serviceType: String
  region: String
  bucketName: String
}

input GetNextBundleForCluster {
  # ID of cluster need to get next bundle
  clusterId: ID!
}

input updateBundleStatusAsCluster {
  # Id of the cluster.
  clusterId: ID!
  # Id of the bundle.
  bundleId: ID!
  # Bundle status body object
  bundleStatus: BundleStatus!
}

input BundleStatus {
  bundleStarted: DateTime
  bundleCompleted: DateTime
  bundleResults: bundleResults!
  markAsCompleted: Boolean
}

input bundleResults {
  found: Int!
  completed: Int!
  errors: bundleError!
}

input bundleError {
  error: String!
}
